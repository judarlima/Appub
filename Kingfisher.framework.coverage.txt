/Users/raduj/Developer/Appub/Pods/Kingfisher/Sources/AnimatedImageView.swift:
    1|       |//
    2|       |//  AnimatableImageView.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by bl4ckra1sond3tre on 4/22/16.
    6|       |//
    7|       |//  The AnimatableImageView, AnimatedFrame and Animator is a modified version of 
    8|       |//  some classes from kaishin's Gifu project (https://github.com/kaishin/Gifu)
    9|       |//
   10|       |//  The MIT License (MIT)
   11|       |//
   12|       |//  Copyright (c) 2018 Reda Lemeden.
   13|       |//
   14|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy of
   15|       |//  this software and associated documentation files (the "Software"), to deal in
   16|       |//  the Software without restriction, including without limitation the rights to
   17|       |//  use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   18|       |//  the Software, and to permit persons to whom the Software is furnished to do so,
   19|       |//  subject to the following conditions:
   20|       |//
   21|       |//  The above copyright notice and this permission notice shall be included in all
   22|       |//  copies or substantial portions of the Software.
   23|       |//
   24|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   25|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
   26|       |//  FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
   27|       |//  COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
   28|       |//  IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
   29|       |//  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   30|       |//
   31|       |//  The name and characters used in the demo of this software are property of their
   32|       |//  respective owners.
   33|       |
   34|       |import UIKit
   35|       |import ImageIO
   36|       |
   37|       |/// Protocol of `AnimatedImageView`.
   38|       |public protocol AnimatedImageViewDelegate: class {
   39|       |    /**
   40|       |     Called after the animatedImageView has finished each animation loop.
   41|       |
   42|       |     - parameter imageView: The animatedImageView that is being animated.
   43|       |     - parameter count: The looped count.
   44|       |     */
   45|       |    func animatedImageView(_ imageView: AnimatedImageView, didPlayAnimationLoops count: UInt)
   46|       |
   47|       |    /**
   48|       |     Called after the animatedImageView has reached the max repeat count.
   49|       |
   50|       |     - parameter imageView: The animatedImageView that is being animated.
   51|       |     */
   52|       |    func animatedImageViewDidFinishAnimating(_ imageView: AnimatedImageView)
   53|       |}
   54|       |
   55|       |extension AnimatedImageViewDelegate {
   56|      0|    public func animatedImageView(_ imageView: AnimatedImageView, didPlayAnimationLoops count: UInt) {}
   57|      0|    public func animatedImageViewDidFinishAnimating(_ imageView: AnimatedImageView) {}
   58|       |}
   59|       |
   60|       |/// `AnimatedImageView` is a subclass of `UIImageView` for displaying animated image.
   61|       |open class AnimatedImageView: UIImageView {
   62|       |    
   63|       |    /// Proxy object for prevending a reference cycle between the CADDisplayLink and AnimatedImageView.
   64|       |    class TargetProxy {
   65|       |        private weak var target: AnimatedImageView?
   66|       |        
   67|      0|        init(target: AnimatedImageView) {
   68|      0|            self.target = target
   69|      0|        }
   70|       |        
   71|      0|        @objc func onScreenUpdate() {
   72|      0|            target?.updateFrame()
   73|      0|        }
   74|       |    }
   75|       |
   76|       |    /// Enumeration that specifies repeat count of GIF
   77|       |    public enum RepeatCount: Equatable {
   78|       |        case once
   79|       |        case finite(count: UInt)
   80|       |        case infinite
   81|       |
   82|      0|        public static func ==(lhs: RepeatCount, rhs: RepeatCount) -> Bool {
   83|      0|            switch (lhs, rhs) {
   84|      0|            case let (.finite(l), .finite(r)):
   85|      0|                return l == r
   86|      0|            case (.once, .once),
   87|      0|                 (.infinite, .infinite):
   88|      0|                return true
   89|      0|            case (.once, _),
   90|      0|                 (.infinite, _),
   91|      0|                 (.finite, _):
   92|      0|                return false
   93|      0|            }
   94|      0|        }
   95|       |    }
   96|       |    
   97|       |    // MARK: - Public property
   98|       |    /// Whether automatically play the animation when the view become visible. Default is true.
   99|       |    public var autoPlayAnimatedImage = true
  100|       |    
  101|       |    /// The size of the frame cache.
  102|       |    public var framePreloadCount = 10
  103|       |    
  104|       |    /// Specifies whether the GIF frames should be pre-scaled to save memory. Default is true.
  105|       |    public var needsPrescaling = true
  106|       |    
  107|       |    /// The animation timer's run loop mode. Default is `NSRunLoopCommonModes`. Set this property to `NSDefaultRunLoopMode` will make the animation pause during UIScrollView scrolling.
  108|       |    public var runLoopMode = RunLoopMode.commonModes {
  109|      0|        willSet {
  110|      0|            if runLoopMode == newValue {
  111|      0|                return
  112|      0|            } else {
  113|      0|                stopAnimating()
  114|      0|                displayLink.remove(from: .main, forMode: runLoopMode)
  115|      0|                displayLink.add(to: .main, forMode: newValue)
  116|      0|                startAnimating()
  117|      0|            }
  118|      0|        }
  119|       |    }
  120|       |
  121|       |    /// The repeat count.
  122|       |    public var repeatCount = RepeatCount.infinite {
  123|      0|        didSet {
  124|      0|            if oldValue != repeatCount {
  125|      0|                reset()
  126|      0|                setNeedsDisplay()
  127|      0|                layer.setNeedsDisplay()
  128|      0|            }
  129|      0|        }
  130|       |    }
  131|       |
  132|       |    /// Delegate of this `AnimatedImageView` object. See `AnimatedImageViewDelegate` protocol for more.
  133|       |    public weak var delegate: AnimatedImageViewDelegate?
  134|       |    
  135|       |    // MARK: - Private property
  136|       |    /// `Animator` instance that holds the frames of a specific image in memory.
  137|       |    private var animator: Animator?
  138|       |    
  139|       |    /// A flag to avoid invalidating the displayLink on deinit if it was never created, because displayLink is so lazy. :D
  140|       |    private var isDisplayLinkInitialized: Bool = false
  141|       |    
  142|       |    /// A display link that keeps calling the `updateFrame` method on every screen refresh.
  143|      0|    private lazy var displayLink: CADisplayLink = {
  144|      0|        self.isDisplayLinkInitialized = true
  145|      0|        let displayLink = CADisplayLink(target: TargetProxy(target: self), selector: #selector(TargetProxy.onScreenUpdate))
  146|      0|        displayLink.add(to: .main, forMode: self.runLoopMode)
  147|      0|        displayLink.isPaused = true
  148|      0|        return displayLink
  149|      0|    }()
  150|       |    
  151|       |    // MARK: - Override
  152|       |    override open var image: Image? {
  153|      0|        didSet {
  154|      0|            if image != oldValue {
  155|      0|                reset()
  156|      0|            }
  157|      0|            setNeedsDisplay()
  158|      0|            layer.setNeedsDisplay()
  159|      0|        }
  160|       |    }
  161|       |    
  162|      0|    deinit {
  163|      0|        if isDisplayLinkInitialized {
  164|      0|            displayLink.invalidate()
  165|      0|        }
  166|      0|    }
  167|       |    
  168|       |    override open var isAnimating: Bool {
  169|       |        if isDisplayLinkInitialized {
  170|       |            return !displayLink.isPaused
  171|       |        } else {
  172|       |            return super.isAnimating
  173|       |        }
  174|       |    }
  175|       |    
  176|       |    /// Starts the animation.
  177|      0|    override open func startAnimating() {
  178|      0|        if self.isAnimating {
  179|      0|            return
  180|      0|        } else {
  181|      0|            if animator?.isReachMaxRepeatCount ?? false {
  182|      0|                return
  183|      0|            }
  184|      0|
  185|      0|            displayLink.isPaused = false
  186|      0|        }
  187|      0|    }
  188|       |    
  189|       |    /// Stops the animation.
  190|      0|    override open func stopAnimating() {
  191|      0|        super.stopAnimating()
  192|      0|        if isDisplayLinkInitialized {
  193|      0|            displayLink.isPaused = true
  194|      0|        }
  195|      0|    }
  196|       |    
  197|      0|    override open func display(_ layer: CALayer) {
  198|      0|        if let currentFrame = animator?.currentFrame {
  199|      0|            layer.contents = currentFrame.cgImage
  200|      0|        } else {
  201|      0|            layer.contents = image?.cgImage
  202|      0|        }
  203|      0|    }
  204|       |    
  205|      0|    override open func didMoveToWindow() {
  206|      0|        super.didMoveToWindow()
  207|      0|        didMove()
  208|      0|    }
  209|       |    
  210|      0|    override open func didMoveToSuperview() {
  211|      0|        super.didMoveToSuperview()
  212|      0|        didMove()
  213|      0|    }
  214|       |
  215|       |    // This is for back compatibility that using regular UIImageView to show animated image.
  216|      0|    override func shouldPreloadAllAnimation() -> Bool {
  217|      0|        return false
  218|      0|    }
  219|       |
  220|       |    // MARK: - Private method
  221|       |    /// Reset the animator.
  222|      0|    private func reset() {
  223|      0|        animator = nil
  224|      0|        if let imageSource = image?.kf.imageSource?.imageRef {
  225|      0|            animator = Animator(imageSource: imageSource,
  226|      0|                                contentMode: contentMode,
  227|      0|                                size: bounds.size,
  228|      0|                                framePreloadCount: framePreloadCount,
  229|      0|                                repeatCount: repeatCount)
  230|      0|            animator?.delegate = self
  231|      0|            animator?.needsPrescaling = needsPrescaling
  232|      0|            animator?.prepareFramesAsynchronously()
  233|      0|        }
  234|      0|        didMove()
  235|      0|    }
  236|       |    
  237|      0|    private func didMove() {
  238|      0|        if autoPlayAnimatedImage && animator != nil {
  239|      0|            if let _ = superview, let _ = window {
  240|      0|                startAnimating()
  241|      0|            } else {
  242|      0|                stopAnimating()
  243|      0|            }
  244|      0|        }
  245|      0|    }
  246|       |    
  247|       |    /// Update the current frame with the displayLink duration.
  248|      0|    private func updateFrame() {
  249|      0|        let duration: CFTimeInterval
  250|      0|
  251|      0|        // CA based display link is opt-out from ProMotion by default.
  252|      0|        // So the duration and its FPS might not match. 
  253|      0|        // See [#718](https://github.com/onevcat/Kingfisher/issues/718)
  254|      0|        if #available(iOS 10.0, tvOS 10.0, *) {
  255|      0|            // By setting CADisableMinimumFrameDuration to YES in Info.plist may 
  256|      0|            // cause the preferredFramesPerSecond being 0
  257|      0|            if displayLink.preferredFramesPerSecond == 0 {
  258|      0|                duration = displayLink.duration
  259|      0|            } else {
  260|      0|                // Some devices (like iPad Pro 10.5) will have a different FPS.
  261|      0|                duration = 1.0 / Double(displayLink.preferredFramesPerSecond)
  262|      0|            }
  263|      0|        } else {
  264|      0|            duration = displayLink.duration
  265|      0|        }
  266|      0|    
  267|      0|        if animator?.updateCurrentFrame(duration: duration) ?? false {
  268|      0|            layer.setNeedsDisplay()
  269|      0|
  270|      0|            if animator?.isReachMaxRepeatCount ?? false {
  271|      0|                stopAnimating()
  272|      0|                delegate?.animatedImageViewDidFinishAnimating(self)
  273|      0|            }
  274|      0|        }
  275|      0|    }
  276|       |}
  277|       |
  278|       |extension AnimatedImageView: AnimatorDelegate {
  279|      0|    func animator(_ animator: Animator, didPlayAnimationLoops count: UInt) {
  280|      0|        delegate?.animatedImageView(self, didPlayAnimationLoops: count)
  281|      0|    }
  282|       |}
  283|       |
  284|       |/// Keeps a reference to an `Image` instance and its duration as a GIF frame.
  285|       |struct AnimatedFrame {
  286|       |    var image: Image?
  287|       |    let duration: TimeInterval
  288|       |    
  289|       |    static let null: AnimatedFrame = AnimatedFrame(image: .none, duration: 0.0)
  290|       |}
  291|       |
  292|       |protocol AnimatorDelegate: class {
  293|       |    func animator(_ animator: Animator, didPlayAnimationLoops count: UInt)
  294|       |}
  295|       |
  296|       |// MARK: - Animator
  297|       |class Animator {
  298|       |    // MARK: Private property
  299|       |    fileprivate let size: CGSize
  300|       |    fileprivate let maxFrameCount: Int
  301|       |    fileprivate let imageSource: CGImageSource
  302|       |    fileprivate let maxRepeatCount: AnimatedImageView.RepeatCount
  303|       |    
  304|       |    fileprivate var animatedFrames = [AnimatedFrame]()
  305|       |    fileprivate let maxTimeStep: TimeInterval = 1.0
  306|       |    fileprivate var frameCount = 0
  307|       |    fileprivate var currentFrameIndex = 0
  308|       |    fileprivate var currentFrameIndexInBuffer = 0
  309|       |    fileprivate var currentPreloadIndex = 0
  310|       |    fileprivate var timeSinceLastFrameChange: TimeInterval = 0.0
  311|       |    fileprivate var needsPrescaling = true
  312|       |    fileprivate var currentRepeatCount: UInt = 0
  313|       |    fileprivate weak var delegate: AnimatorDelegate?
  314|       |    
  315|       |    /// Loop count of animated image.
  316|       |    private var loopCount = 0
  317|       |    
  318|      0|    var currentFrame: UIImage? {
  319|      0|        return frame(at: currentFrameIndexInBuffer)
  320|      0|    }
  321|       |
  322|      0|    var isReachMaxRepeatCount: Bool {
  323|      0|        switch maxRepeatCount {
  324|      0|        case .once:
  325|      0|            return currentRepeatCount >= 1
  326|      0|        case .finite(let maxCount):
  327|      0|            return currentRepeatCount >= maxCount
  328|      0|        case .infinite:
  329|      0|            return false
  330|      0|        }
  331|      0|    }
  332|       |    
  333|       |    var contentMode = UIViewContentMode.scaleToFill
  334|       |    
  335|      0|    private lazy var preloadQueue: DispatchQueue = {
  336|      0|        return DispatchQueue(label: "com.onevcat.Kingfisher.Animator.preloadQueue")
  337|      0|    }()
  338|       |    
  339|       |    /**
  340|       |     Init an animator with image source reference.
  341|       |     
  342|       |     - parameter imageSource: The reference of animated image.
  343|       |     - parameter contentMode: Content mode of AnimatedImageView.
  344|       |     - parameter size: Size of AnimatedImageView.
  345|       |     - parameter framePreloadCount: Frame cache size.
  346|       |     
  347|       |     - returns: The animator object.
  348|       |     */
  349|       |    init(imageSource source: CGImageSource,
  350|       |         contentMode mode: UIViewContentMode,
  351|       |         size: CGSize,
  352|       |         framePreloadCount count: Int,
  353|      0|         repeatCount: AnimatedImageView.RepeatCount) {
  354|      0|        self.imageSource = source
  355|      0|        self.contentMode = mode
  356|      0|        self.size = size
  357|      0|        self.maxFrameCount = count
  358|      0|        self.maxRepeatCount = repeatCount
  359|      0|    }
  360|       |    
  361|      0|    func frame(at index: Int) -> Image? {
  362|      0|        return animatedFrames[safe: index]?.image
  363|      0|    }
  364|       |    
  365|      0|    func prepareFramesAsynchronously() {
  366|      0|        preloadQueue.async { [weak self] in
  367|      0|            self?.prepareFrames()
  368|      0|        }
  369|      0|    }
  370|       |    
  371|      0|    private func prepareFrames() {
  372|      0|        frameCount = CGImageSourceGetCount(imageSource)
  373|      0|        
  374|      0|        if let properties = CGImageSourceCopyProperties(imageSource, nil),
  375|      0|            let gifInfo = (properties as NSDictionary)[kCGImagePropertyGIFDictionary as String] as? NSDictionary,
  376|      0|            let loopCount = gifInfo[kCGImagePropertyGIFLoopCount as String] as? Int
  377|      0|        {
  378|      0|            self.loopCount = loopCount
  379|      0|        }
  380|      0|        
  381|      0|        let frameToProcess = min(frameCount, maxFrameCount)
  382|      0|        animatedFrames.reserveCapacity(frameToProcess)
  383|      0|        animatedFrames = (0..<frameToProcess).reduce([]) { $0 + pure(prepareFrame(at: $1))}
  384|      0|        currentPreloadIndex = (frameToProcess + 1) % frameCount - 1
  385|      0|    }
  386|       |    
  387|      0|    private func prepareFrame(at index: Int) -> AnimatedFrame {
  388|      0|        
  389|      0|        guard let imageRef = CGImageSourceCreateImageAtIndex(imageSource, index, nil) else {
  390|      0|            return AnimatedFrame.null
  391|      0|        }
  392|      0|        
  393|      0|        let defaultGIFFrameDuration = 0.100
  394|      0|        let frameDuration = imageSource.kf.gifProperties(at: index).map {
  395|      0|            gifInfo -> Double in
  396|      0|            
  397|      0|            let unclampedDelayTime = gifInfo[kCGImagePropertyGIFUnclampedDelayTime as String] as Double?
  398|      0|            let delayTime = gifInfo[kCGImagePropertyGIFDelayTime as String] as Double?
  399|      0|            let duration = unclampedDelayTime ?? delayTime ?? 0.0
  400|      0|            
  401|      0|            /**
  402|      0|             http://opensource.apple.com/source/WebCore/WebCore-7600.1.25/platform/graphics/cg/ImageSourceCG.cpp
  403|      0|             Many annoying ads specify a 0 duration to make an image flash as quickly as
  404|      0|             possible. We follow Safari and Firefox's behavior and use a duration of 100 ms
  405|      0|             for any frames that specify a duration of <= 10 ms.
  406|      0|             See <rdar://problem/7689300> and <http://webkit.org/b/36082> for more information.
  407|      0|             
  408|      0|             See also: http://nullsleep.tumblr.com/post/16524517190/animated-gif-minimum-frame-delay-browser.
  409|      0|             */
  410|      0|            return duration > 0.011 ? duration : defaultGIFFrameDuration
  411|      0|        } ?? defaultGIFFrameDuration
  412|      0|        
  413|      0|        let image = Image(cgImage: imageRef)
  414|      0|        let scaledImage: Image?
  415|      0|        
  416|      0|        if needsPrescaling {
  417|      0|            scaledImage = image.kf.resize(to: size, for: contentMode)
  418|      0|        } else {
  419|      0|            scaledImage = image
  420|      0|        }
  421|      0|        
  422|      0|        return AnimatedFrame(image: scaledImage, duration: frameDuration)
  423|      0|    }
  424|       |    
  425|       |    /**
  426|       |     Updates the current frame if necessary using the frame timer and the duration of each frame in `animatedFrames`.
  427|       |     */
  428|      0|    func updateCurrentFrame(duration: CFTimeInterval) -> Bool {
  429|      0|        timeSinceLastFrameChange += min(maxTimeStep, duration)
  430|      0|        guard let frameDuration = animatedFrames[safe: currentFrameIndexInBuffer]?.duration, frameDuration <= timeSinceLastFrameChange else {
  431|      0|            return false
  432|      0|        }
  433|      0|        
  434|      0|        timeSinceLastFrameChange -= frameDuration
  435|      0|        
  436|      0|        let lastFrameIndex = currentFrameIndexInBuffer
  437|      0|        currentFrameIndexInBuffer += 1
  438|      0|        currentFrameIndexInBuffer = currentFrameIndexInBuffer % animatedFrames.count
  439|      0|        
  440|      0|        if animatedFrames.count < frameCount {
  441|      0|            preloadFrameAsynchronously(at: lastFrameIndex)
  442|      0|        }
  443|      0|        
  444|      0|        currentFrameIndex += 1
  445|      0|        
  446|      0|        if currentFrameIndex == frameCount {
  447|      0|            currentFrameIndex = 0
  448|      0|            currentRepeatCount += 1
  449|      0|
  450|      0|            delegate?.animator(self, didPlayAnimationLoops: currentRepeatCount)
  451|      0|        }
  452|      0|
  453|      0|        return true
  454|      0|    }
  455|       |    
  456|      0|    private func preloadFrameAsynchronously(at index: Int) {
  457|      0|        preloadQueue.async { [weak self] in
  458|      0|            self?.preloadFrame(at: index)
  459|      0|        }
  460|      0|    }
  461|       |    
  462|      0|    private func preloadFrame(at index: Int) {
  463|      0|        animatedFrames[index] = prepareFrame(at: currentPreloadIndex)
  464|      0|        currentPreloadIndex += 1
  465|      0|        currentPreloadIndex = currentPreloadIndex % frameCount
  466|      0|    }
  467|       |}
  468|       |
  469|       |extension CGImageSource: KingfisherCompatible { }
  470|       |extension Kingfisher where Base: CGImageSource {
  471|       |    func gifProperties(at index: Int) -> [String: Double]? {
  472|       |        let properties = CGImageSourceCopyPropertiesAtIndex(base, index, nil) as Dictionary?
  473|       |        return properties?[kCGImagePropertyGIFDictionary] as? [String: Double]
  474|       |    }
  475|       |}
  476|       |
  477|       |extension Array {
  478|       |    fileprivate subscript(safe index: Int) -> Element? {
  479|       |        return indices ~= index ? self[index] : nil
  480|       |    }
  481|       |}
  482|       |
  483|       |private func pure<T>(_ value: T) -> [T] {
  484|       |    return [value]
  485|       |}

/Users/raduj/Developer/Appub/Pods/Kingfisher/Sources/Box.swift:
    1|       |//
    2|       |//  Box.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 2018/3/17.
    6|       |//  Copyright (c) 2018 Wei Wang <onevcat@gmail.com>
    7|       |//
    8|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
    9|       |//  of this software and associated documentation files (the "Software"), to deal
   10|       |//  in the Software without restriction, including without limitation the rights
   11|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   12|       |//  copies of the Software, and to permit persons to whom the Software is
   13|       |//  furnished to do so, subject to the following conditions:
   14|       |//
   15|       |//  The above copyright notice and this permission notice shall be included in
   16|       |//  all copies or substantial portions of the Software.
   17|       |//
   18|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   19|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   20|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   21|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   22|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   23|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   24|       |//  THE SOFTWARE.
   25|       |
   26|       |import Foundation
   27|       |
   28|       |class Box<T> {
   29|       |    let value: T
   30|       |    
   31|      0|    init(_ value: T) {
   32|      0|        self.value = value
   33|      0|    }
   34|       |}

/Users/raduj/Developer/Appub/Pods/Kingfisher/Sources/CacheSerializer.swift:
    1|       |//
    2|       |//  CacheSerializer.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 2016/09/02.
    6|       |//
    7|       |//  Copyright (c) 2018 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import Foundation
   28|       |
   29|       |/// An `CacheSerializer` would be used to convert some data to an image object for 
   30|       |/// retrieving from disk cache and vice versa for storing to disk cache.
   31|       |public protocol CacheSerializer {
   32|       |    
   33|       |    /// Get the serialized data from a provided image
   34|       |    /// and optional original data for caching to disk.
   35|       |    ///
   36|       |    ///
   37|       |    /// - parameter image:    The image needed to be serialized.
   38|       |    /// - parameter original: The original data which is just downloaded. 
   39|       |    ///                       If the image is retrieved from cache instead of
   40|       |    ///                       downloaded, it will be `nil`.
   41|       |    ///
   42|       |    /// - returns: A data which will be stored to cache, or `nil` when no valid
   43|       |    ///            data could be serialized.
   44|       |    func data(with image: Image, original: Data?) -> Data?
   45|       |    
   46|       |    /// Get an image deserialized from provided data.
   47|       |    ///
   48|       |    /// - parameter data:    The data from which an image should be deserialized.
   49|       |    /// - parameter options: Options for deserialization.
   50|       |    ///
   51|       |    /// - returns: An image deserialized or `nil` when no valid image 
   52|       |    ///            could be deserialized.
   53|       |    func image(with data: Data, options: KingfisherOptionsInfo?) -> Image?
   54|       |}
   55|       |
   56|       |
   57|       |/// `DefaultCacheSerializer` is a basic `CacheSerializer` used in default cache of
   58|       |/// Kingfisher. It could serialize and deserialize PNG, JEPG and GIF images. For 
   59|       |/// image other than these formats, a normalized `pngRepresentation` will be used.
   60|       |public struct DefaultCacheSerializer: CacheSerializer {
   61|       |    
   62|       |    public static let `default` = DefaultCacheSerializer()
   63|      0|    private init() {}
   64|       |    
   65|      0|    public func data(with image: Image, original: Data?) -> Data? {
   66|      0|        let imageFormat = original?.kf.imageFormat ?? .unknown
   67|      0|
   68|      0|        let data: Data?
   69|      0|        switch imageFormat {
   70|      0|        case .PNG: data = image.kf.pngRepresentation()
   71|      0|        case .JPEG: data = image.kf.jpegRepresentation(compressionQuality: 1.0)
   72|      0|        case .GIF: data = image.kf.gifRepresentation()
   73|      0|        case .unknown: data = original ?? image.kf.normalized.kf.pngRepresentation()
   74|      0|        }
   75|      0|
   76|      0|        return data
   77|      0|    }
   78|       |    
   79|      0|    public func image(with data: Data, options: KingfisherOptionsInfo?) -> Image? {
   80|      0|        let options = options ?? KingfisherEmptyOptionsInfo
   81|      0|        return Kingfisher<Image>.image(
   82|      0|            data: data,
   83|      0|            scale: options.scaleFactor,
   84|      0|            preloadAllAnimationData: options.preloadAllAnimationData,
   85|      0|            onlyFirstFrame: options.onlyLoadFirstFrame)
   86|      0|    }
   87|       |}

/Users/raduj/Developer/Appub/Pods/Kingfisher/Sources/Filter.swift:
    1|       |//
    2|       |//  Filter.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 2016/08/31.
    6|       |//
    7|       |//  Copyright (c) 2018 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |
   28|       |
   29|       |import CoreImage
   30|       |import Accelerate
   31|       |
   32|       |// Reuse the same CI Context for all CI drawing.
   33|       |private let ciContext = CIContext(options: nil)
   34|       |
   35|       |/// Transformer method which will be used in to provide a `Filter`.
   36|       |public typealias Transformer = (CIImage) -> CIImage?
   37|       |
   38|       |/// Supply a filter to create an `ImageProcessor`.
   39|       |public protocol CIImageProcessor: ImageProcessor {
   40|       |    var filter: Filter { get }
   41|       |}
   42|       |
   43|       |extension CIImageProcessor {
   44|      0|    public func process(item: ImageProcessItem, options: KingfisherOptionsInfo) -> Image? {
   45|      0|        switch item {
   46|      0|        case .image(let image):
   47|      0|            return image.kf.apply(filter)
   48|      0|        case .data(_):
   49|      0|            return (DefaultImageProcessor.default >> self).process(item: item, options: options)
   50|      0|        }
   51|      0|    }
   52|       |}
   53|       |
   54|       |/// Wrapper for a `Transformer` of CIImage filters.
   55|       |public struct Filter {
   56|       |    
   57|       |    let transform: Transformer
   58|       |
   59|      0|    public init(transform: @escaping Transformer) {
   60|      0|        self.transform = transform
   61|      0|    }
   62|       |    
   63|       |    /// Tint filter which will apply a tint color to images.
   64|      0|    public static var tint: (Color) -> Filter = {
   65|      0|        color in
   66|      0|        Filter(transform: { input in
   67|      0|            let colorFilter = CIFilter(name: "CIConstantColorGenerator")!
   68|      0|            colorFilter.setValue(CIColor(color: color), forKey: kCIInputColorKey)
   69|      0|            
   70|      0|            let colorImage = colorFilter.outputImage
   71|      0|            let filter = CIFilter(name: "CISourceOverCompositing")!
   72|      0|            filter.setValue(colorImage, forKey: kCIInputImageKey)
   73|      0|            filter.setValue(input, forKey: kCIInputBackgroundImageKey)
   74|      0|            #if swift(>=4.0)
   75|      0|            return filter.outputImage?.cropped(to: input.extent)
   76|      0|            #else
   77|      0|            return filter.outputImage?.cropping(to: input.extent)
   78|      0|            #endif
   79|      0|        })
   80|      0|    }
   81|       |    
   82|       |    public typealias ColorElement = (CGFloat, CGFloat, CGFloat, CGFloat)
   83|       |    
   84|       |    /// Color control filter which will apply color control change to images.
   85|      0|    public static var colorControl: (ColorElement) -> Filter = { arg -> Filter in
   86|      0|        let (brightness, contrast, saturation, inputEV) = arg
   87|      0|        return Filter(transform: { input in
   88|      0|            let paramsColor = [kCIInputBrightnessKey: brightness,
   89|      0|                               kCIInputContrastKey: contrast,
   90|      0|                               kCIInputSaturationKey: saturation]
   91|      0|            
   92|      0|            let paramsExposure = [kCIInputEVKey: inputEV]
   93|      0|            #if swift(>=4.0)
   94|      0|            let blackAndWhite = input.applyingFilter("CIColorControls", parameters: paramsColor)
   95|      0|            return blackAndWhite.applyingFilter("CIExposureAdjust", parameters: paramsExposure)
   96|      0|            #else
   97|      0|            let blackAndWhite = input.applyingFilter("CIColorControls", withInputParameters: paramsColor)
   98|      0|            return blackAndWhite.applyingFilter("CIExposureAdjust", withInputParameters: paramsExposure)
   99|      0|            #endif
  100|      0|        })
  101|      0|    }
  102|       |}
  103|       |
  104|       |// MARK: - Deprecated
  105|       |extension Filter {
  106|       |    @available(*, deprecated, message: "Use init(transform:) instead.", renamed: "init(transform:)")
  107|      0|    public init(tranform: @escaping Transformer) {
  108|      0|        self.transform = tranform
  109|      0|    }
  110|       |}
  111|       |
  112|       |extension Kingfisher where Base: Image {
  113|       |    /// Apply a `Filter` containing `CIImage` transformer to `self`.
  114|       |    ///
  115|       |    /// - parameter filter: The filter used to transform `self`.
  116|       |    ///
  117|       |    /// - returns: A transformed image by input `Filter`.
  118|       |    ///
  119|       |    /// - Note: Only CG-based images are supported. If any error happens during transforming, `self` will be returned.
  120|       |    public func apply(_ filter: Filter) -> Image {
  121|       |        
  122|       |        guard let cgImage = cgImage else {
  123|      0|            assertionFailure("[Kingfisher] Tint image only works for CG-based image.")
  124|       |            return base
  125|       |        }
  126|       |        
  127|       |        let inputImage = CIImage(cgImage: cgImage)
  128|       |        guard let outputImage = filter.transform(inputImage) else {
  129|       |            return base
  130|       |        }
  131|       |        
  132|       |        guard let result = ciContext.createCGImage(outputImage, from: outputImage.extent) else {
  133|      0|            assertionFailure("[Kingfisher] Can not make an tint image within context.")
  134|       |            return base
  135|       |        }
  136|       |        
  137|       |        #if os(macOS)
  138|       |            return fixedForRetinaPixel(cgImage: result, to: size)
  139|       |        #else
  140|       |            return Image(cgImage: result, scale: base.scale, orientation: base.imageOrientation)
  141|       |        #endif
  142|       |    }
  143|       |
  144|       |}

/Users/raduj/Developer/Appub/Pods/Kingfisher/Sources/FormatIndicatedCacheSerializer.swift:
    1|       |//
    2|       |//  RequestModifier.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Junyu Kuang on 5/28/17.
    6|       |//
    7|       |//  Copyright (c) 2018 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import Foundation
   28|       |
   29|       |/// `FormatIndicatedCacheSerializer` let you indicate an image format for serialized caches.
   30|       |///
   31|       |/// It could serialize and deserialize PNG, JEPG and GIF images. For
   32|       |/// image other than these formats, a normalized `pngRepresentation` will be used.
   33|       |///
   34|       |/// Example:
   35|       |/// ````
   36|       |/// private let profileImageSize = CGSize(width: 44, height: 44)
   37|       |///
   38|       |/// private let imageProcessor = RoundCornerImageProcessor(
   39|       |///     cornerRadius: profileImageSize.width / 2, targetSize: profileImageSize)
   40|       |///
   41|       |/// private let optionsInfo: KingfisherOptionsInfo = [
   42|       |///     .cacheSerializer(FormatIndicatedCacheSerializer.png), 
   43|       |///     .backgroundDecode, .processor(imageProcessor), .scaleFactor(UIScreen.main.scale)]
   44|       |///
   45|       |/// extension UIImageView {
   46|       |///    func setProfileImage(with url: URL) {
   47|       |///        // Image will always cached as PNG format to preserve alpha channel for round rect.
   48|       |///        _ = kf.setImage(with: url, options: optionsInfo)
   49|       |///    }
   50|       |///}
   51|       |/// ````
   52|       |public struct FormatIndicatedCacheSerializer: CacheSerializer {
   53|       |    
   54|       |    public static let png = FormatIndicatedCacheSerializer(imageFormat: .PNG)
   55|       |    public static let jpeg = FormatIndicatedCacheSerializer(imageFormat: .JPEG)
   56|       |    public static let gif = FormatIndicatedCacheSerializer(imageFormat: .GIF)
   57|       |    
   58|       |    /// The indicated image format.
   59|       |    private let imageFormat: ImageFormat
   60|       |    
   61|      0|    public func data(with image: Image, original: Data?) -> Data? {
   62|      0|        
   63|      0|        func imageData(withFormat imageFormat: ImageFormat) -> Data? {
   64|      0|            switch imageFormat {
   65|      0|            case .PNG: return image.kf.pngRepresentation()
   66|      0|            case .JPEG: return image.kf.jpegRepresentation(compressionQuality: 1.0)
   67|      0|            case .GIF: return image.kf.gifRepresentation()
   68|      0|            case .unknown: return nil
   69|      0|            }
   70|      0|        }
   71|      0|        
   72|      0|        // generate data with indicated image format
   73|      0|        if let data = imageData(withFormat: imageFormat) {
   74|      0|            return data
   75|      0|        }
   76|      0|        
   77|      0|        let originalFormat = original?.kf.imageFormat ?? .unknown
   78|      0|        
   79|      0|        // generate data with original image's format
   80|      0|        if originalFormat != imageFormat, let data = imageData(withFormat: originalFormat) {
   81|      0|            return data
   82|      0|        }
   83|      0|        
   84|      0|        return original ?? image.kf.normalized.kf.pngRepresentation()
   85|      0|    }
   86|       |    
   87|       |    /// Same implementation as `DefaultCacheSerializer`.
   88|      0|    public func image(with data: Data, options: KingfisherOptionsInfo?) -> Image? {
   89|      0|        let options = options ?? KingfisherEmptyOptionsInfo
   90|      0|        return Kingfisher<Image>.image(
   91|      0|            data: data,
   92|      0|            scale: options.scaleFactor,
   93|      0|            preloadAllAnimationData: options.preloadAllAnimationData,
   94|      0|            onlyFirstFrame: options.onlyLoadFirstFrame)
   95|      0|    }
   96|       |}

/Users/raduj/Developer/Appub/Pods/Kingfisher/Sources/Image.swift:
    1|       |//
    2|       |//  Image.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 16/1/6.
    6|       |//
    7|       |//  Copyright (c) 2018 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |
   28|       |#if os(macOS)
   29|       |import AppKit
   30|       |private var imagesKey: Void?
   31|       |private var durationKey: Void?
   32|       |#else
   33|       |import UIKit
   34|       |import MobileCoreServices
   35|       |private var imageSourceKey: Void?
   36|       |#endif
   37|       |private var animatedImageDataKey: Void?
   38|       |
   39|       |import ImageIO
   40|       |import CoreGraphics
   41|       |
   42|       |#if !os(watchOS)
   43|       |import Accelerate
   44|       |import CoreImage
   45|       |#endif
   46|       |
   47|       |// MARK: - Image Properties
   48|       |extension Kingfisher where Base: Image {
   49|       |    fileprivate(set) var animatedImageData: Data? {
   50|      0|        get {
   51|      0|            return objc_getAssociatedObject(base, &animatedImageDataKey) as? Data
   52|      0|        }
   53|      0|        set {
   54|      0|            objc_setAssociatedObject(base, &animatedImageDataKey, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
   55|      0|        }
   56|       |    }
   57|       |    
   58|       |    #if os(macOS)
   59|       |    var cgImage: CGImage? {
   60|       |        return base.cgImage(forProposedRect: nil, context: nil, hints: nil)
   61|       |    }
   62|       |    
   63|       |    var scale: CGFloat {
   64|       |        return 1.0
   65|       |    }
   66|       |    
   67|       |    fileprivate(set) var images: [Image]? {
   68|       |        get {
   69|       |            return objc_getAssociatedObject(base, &imagesKey) as? [Image]
   70|       |        }
   71|       |        set {
   72|       |            objc_setAssociatedObject(base, &imagesKey, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
   73|       |        }
   74|       |    }
   75|       |    
   76|       |    fileprivate(set) var duration: TimeInterval {
   77|       |        get {
   78|       |            return objc_getAssociatedObject(base, &durationKey) as? TimeInterval ?? 0.0
   79|       |        }
   80|       |        set {
   81|       |            objc_setAssociatedObject(base, &durationKey, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
   82|       |        }
   83|       |    }
   84|       |    
   85|       |    var size: CGSize {
   86|       |        return base.representations.reduce(CGSize.zero, { size, rep in
   87|       |            return CGSize(width: max(size.width, CGFloat(rep.pixelsWide)), height: max(size.height, CGFloat(rep.pixelsHigh)))
   88|       |        })
   89|       |    }
   90|       |    
   91|       |    #else
   92|      0|    var cgImage: CGImage? {
   93|      0|        return base.cgImage
   94|      0|    }
   95|       |    
   96|      0|    var scale: CGFloat {
   97|      0|        return base.scale
   98|      0|    }
   99|       |    
  100|      0|    var images: [Image]? {
  101|      0|        return base.images
  102|      0|    }
  103|       |    
  104|      0|    var duration: TimeInterval {
  105|      0|        return base.duration
  106|      0|    }
  107|       |    
  108|       |    fileprivate(set) var imageSource: ImageSource? {
  109|      0|        get {
  110|      0|            return objc_getAssociatedObject(base, &imageSourceKey) as? ImageSource
  111|      0|        }
  112|      0|        set {
  113|      0|            objc_setAssociatedObject(base, &imageSourceKey, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
  114|      0|        }
  115|       |    }
  116|       |    
  117|      0|    var size: CGSize {
  118|      0|        return base.size
  119|      0|    }
  120|       |    #endif
  121|       |}
  122|       |
  123|       |// MARK: - Image Conversion
  124|       |extension Kingfisher where Base: Image {
  125|       |    #if os(macOS)
  126|       |    static func image(cgImage: CGImage, scale: CGFloat, refImage: Image?) -> Image {
  127|       |        return Image(cgImage: cgImage, size: CGSize.zero)
  128|       |    }
  129|       |    
  130|       |    /**
  131|       |     Normalize the image. This method does nothing in OS X.
  132|       |     
  133|       |     - returns: The image itself.
  134|       |     */
  135|       |    public var normalized: Image {
  136|       |        return base
  137|       |    }
  138|       |    
  139|       |    static func animated(with images: [Image], forDuration forDurationduration: TimeInterval) -> Image? {
  140|       |        return nil
  141|       |    }
  142|       |    #else
  143|      0|    static func image(cgImage: CGImage, scale: CGFloat, refImage: Image?) -> Image {
  144|      0|        if let refImage = refImage {
  145|      0|            return Image(cgImage: cgImage, scale: scale, orientation: refImage.imageOrientation)
  146|      0|        } else {
  147|      0|            return Image(cgImage: cgImage, scale: scale, orientation: .up)
  148|      0|        }
  149|      0|    }
  150|       |    
  151|       |    /**
  152|       |     Normalize the image. This method will try to redraw an image with orientation and scale considered.
  153|       |     
  154|       |     - returns: The normalized image with orientation set to up and correct scale.
  155|       |     */
  156|      0|    public var normalized: Image {
  157|      0|        // prevent animated image (GIF) lose it's images
  158|      0|        guard images == nil else { return base }
  159|      0|        // No need to do anything if already up
  160|      0|        guard base.imageOrientation != .up else { return base }
  161|      0|    
  162|      0|        return draw(cgImage: nil, to: size) {
  163|      0|            base.draw(in: CGRect(origin: CGPoint.zero, size: size))
  164|      0|        }
  165|      0|    }
  166|       |    
  167|      0|    static func animated(with images: [Image], forDuration duration: TimeInterval) -> Image? {
  168|      0|        return .animatedImage(with: images, duration: duration)
  169|      0|    }
  170|       |    #endif
  171|       |}
  172|       |
  173|       |// MARK: - Image Representation
  174|       |extension Kingfisher where Base: Image {
  175|       |    // MARK: - PNG
  176|      0|    public func pngRepresentation() -> Data? {
  177|      0|        #if os(macOS)
  178|      0|            guard let cgimage = cgImage else {
  179|      0|                return nil
  180|      0|            }
  181|      0|            let rep = NSBitmapImageRep(cgImage: cgimage)
  182|      0|            return rep.representation(using: .png, properties: [:])
  183|      0|        #else
  184|      0|            return UIImagePNGRepresentation(base)
  185|      0|        #endif
  186|      0|    }
  187|       |    
  188|       |    // MARK: - JPEG
  189|      0|    public func jpegRepresentation(compressionQuality: CGFloat) -> Data? {
  190|      0|        #if os(macOS)
  191|      0|            guard let cgImage = cgImage else {
  192|      0|                return nil
  193|      0|            }
  194|      0|            let rep = NSBitmapImageRep(cgImage: cgImage)
  195|      0|            return rep.representation(using:.jpeg, properties: [.compressionFactor: compressionQuality])
  196|      0|        #else
  197|      0|            return UIImageJPEGRepresentation(base, compressionQuality)
  198|      0|        #endif
  199|      0|    }
  200|       |    
  201|       |    // MARK: - GIF
  202|      0|    public func gifRepresentation() -> Data? {
  203|      0|        return animatedImageData
  204|      0|    }
  205|       |}
  206|       |
  207|       |// MARK: - Create images from data
  208|       |extension Kingfisher where Base: Image {
  209|      0|    static func animated(with data: Data, scale: CGFloat = 1.0, duration: TimeInterval = 0.0, preloadAll: Bool, onlyFirstFrame: Bool = false) -> Image? {
  210|      0|        
  211|      0|        func decode(from imageSource: CGImageSource, for options: NSDictionary) -> ([Image], TimeInterval)? {
  212|      0|            
  213|      0|            //Calculates frame duration for a gif frame out of the kCGImagePropertyGIFDictionary dictionary
  214|      0|            func frameDuration(from gifInfo: NSDictionary?) -> Double {
  215|      0|                let gifDefaultFrameDuration = 0.100
  216|      0|                
  217|      0|                guard let gifInfo = gifInfo else {
  218|      0|                    return gifDefaultFrameDuration
  219|      0|                }
  220|      0|                
  221|      0|                let unclampedDelayTime = gifInfo[kCGImagePropertyGIFUnclampedDelayTime as String] as? NSNumber
  222|      0|                let delayTime = gifInfo[kCGImagePropertyGIFDelayTime as String] as? NSNumber
  223|      0|                let duration = unclampedDelayTime ?? delayTime
  224|      0|                
  225|      0|                guard let frameDuration = duration else { return gifDefaultFrameDuration }
  226|      0|                
  227|      0|                return frameDuration.doubleValue > 0.011 ? frameDuration.doubleValue : gifDefaultFrameDuration
  228|      0|            }
  229|      0|            
  230|      0|            let frameCount = CGImageSourceGetCount(imageSource)
  231|      0|            var images = [Image]()
  232|      0|            var gifDuration = 0.0
  233|      0|            for i in 0 ..< frameCount {
  234|      0|                
  235|      0|                guard let imageRef = CGImageSourceCreateImageAtIndex(imageSource, i, options) else {
  236|      0|                    return nil
  237|      0|                }
  238|      0|
  239|      0|                if frameCount == 1 {
  240|      0|                    // Single frame
  241|      0|                    gifDuration = Double.infinity
  242|      0|                } else {
  243|      0|                    
  244|      0|                    // Animated GIF
  245|      0|                    guard let properties = CGImageSourceCopyPropertiesAtIndex(imageSource, i, nil) else {
  246|      0|                        return nil
  247|      0|                    }
  248|      0|
  249|      0|                    let gifInfo = (properties as NSDictionary)[kCGImagePropertyGIFDictionary as String] as? NSDictionary
  250|      0|                    gifDuration += frameDuration(from: gifInfo)
  251|      0|                }
  252|      0|                
  253|      0|                images.append(Kingfisher<Image>.image(cgImage: imageRef, scale: scale, refImage: nil))
  254|      0|                
  255|      0|                if onlyFirstFrame { break }
  256|      0|            }
  257|      0|            
  258|      0|            return (images, gifDuration)
  259|      0|        }
  260|      0|        
  261|      0|        // Start of kf.animatedImageWithGIFData
  262|      0|        let options: NSDictionary = [kCGImageSourceShouldCache as String: true, kCGImageSourceTypeIdentifierHint as String: kUTTypeGIF]
  263|      0|        guard let imageSource = CGImageSourceCreateWithData(data as CFData, options) else {
  264|      0|            return nil
  265|      0|        }
  266|      0|        
  267|      0|        #if os(macOS)
  268|      0|            guard let (images, gifDuration) = decode(from: imageSource, for: options) else {
  269|      0|                return nil
  270|      0|            }
  271|      0|            let image: Image?
  272|      0|            if onlyFirstFrame {
  273|      0|                image = images.first
  274|      0|            } else {
  275|      0|                image = Image(data: data)
  276|      0|                image?.kf.images = images
  277|      0|                image?.kf.duration = gifDuration
  278|      0|            }
  279|      0|            image?.kf.animatedImageData = data
  280|      0|            return image
  281|      0|        #else
  282|      0|            
  283|      0|            let image: Image?
  284|      0|            if preloadAll || onlyFirstFrame {
  285|      0|                guard let (images, gifDuration) = decode(from: imageSource, for: options) else { return nil }
  286|      0|                image = onlyFirstFrame ? images.first : Kingfisher<Image>.animated(with: images, forDuration: duration <= 0.0 ? gifDuration : duration)
  287|      0|            } else {
  288|      0|                image = Image(data: data)
  289|      0|                image?.kf.imageSource = ImageSource(ref: imageSource)
  290|      0|            }
  291|      0|            image?.kf.animatedImageData = data
  292|      0|            return image
  293|      0|        #endif
  294|      0|    }
  295|       |
  296|      0|    static func image(data: Data, scale: CGFloat, preloadAllAnimationData: Bool, onlyFirstFrame: Bool) -> Image? {
  297|      0|        var image: Image?
  298|      0|
  299|      0|        #if os(macOS)
  300|      0|            switch data.kf.imageFormat {
  301|      0|            case .JPEG:
  302|      0|                image = Image(data: data)
  303|      0|            case .PNG:
  304|      0|                image = Image(data: data)
  305|      0|            case .GIF:
  306|      0|                image = Kingfisher<Image>.animated(
  307|      0|                    with: data,
  308|      0|                    scale: scale,
  309|      0|                    duration: 0.0,
  310|      0|                    preloadAll: preloadAllAnimationData,
  311|      0|                    onlyFirstFrame: onlyFirstFrame)
  312|      0|            case .unknown:
  313|      0|                image = Image(data: data)
  314|      0|            }
  315|      0|        #else
  316|      0|            switch data.kf.imageFormat {
  317|      0|            case .JPEG:
  318|      0|                image = Image(data: data, scale: scale)
  319|      0|            case .PNG:
  320|      0|                image = Image(data: data, scale: scale)
  321|      0|            case .GIF:
  322|      0|                image = Kingfisher<Image>.animated(
  323|      0|                    with: data,
  324|      0|                    scale: scale,
  325|      0|                    duration: 0.0,
  326|      0|                    preloadAll: preloadAllAnimationData,
  327|      0|                    onlyFirstFrame: onlyFirstFrame)
  328|      0|            case .unknown:
  329|      0|                image = Image(data: data, scale: scale)
  330|      0|            }
  331|      0|        #endif
  332|      0|
  333|      0|        return image
  334|      0|    }
  335|       |}
  336|       |
  337|       |// MARK: - Image Transforming
  338|       |extension Kingfisher where Base: Image {
  339|       |    // MARK: - Blend Mode
  340|       |    /// Create image based on `self` and apply blend mode.
  341|       |    ///
  342|       |    /// - parameter blendMode:       The blend mode of creating image.
  343|       |    /// - parameter alpha:           The alpha should be used for image.
  344|       |    /// - parameter backgroundColor: The background color for the output image.
  345|       |    ///
  346|       |    /// - returns: An image with blend mode applied.
  347|       |    ///
  348|       |    /// - Note: This method only works for CG-based image.
  349|       |    #if !os(macOS)
  350|       |    public func image(withBlendMode blendMode: CGBlendMode,
  351|       |                      alpha: CGFloat = 1.0,
  352|       |                      backgroundColor: Color? = nil) -> Image
  353|      0|    {
  354|      0|        guard let cgImage = cgImage else {
  355|      0|            assertionFailure("[Kingfisher] Blend mode image only works for CG-based image.")
  356|      0|            return base
  357|      0|        }
  358|      0|
  359|      0|        let rect = CGRect(origin: .zero, size: size)
  360|      0|        return draw(cgImage: cgImage, to: rect.size) {
  361|      0|            if let backgroundColor = backgroundColor {
  362|      0|                backgroundColor.setFill()
  363|      0|                UIRectFill(rect)
  364|      0|            }
  365|      0|
  366|      0|            base.draw(in: rect, blendMode: blendMode, alpha: alpha)
  367|      0|        }
  368|      0|    }
  369|       |    #endif
  370|       |
  371|       |    // MARK: - Compositing Operation
  372|       |    /// Create image based on `self` and apply compositing operation.
  373|       |    ///
  374|       |    /// - parameter compositingOperation: The compositing operation of creating image.
  375|       |    /// - parameter alpha:                The alpha should be used for image.
  376|       |    /// - parameter backgroundColor:      The background color for the output image.
  377|       |    ///
  378|       |    /// - returns: An image with compositing operation applied.
  379|       |    ///
  380|       |    /// - Note: This method only works for CG-based image.
  381|       |    #if os(macOS)
  382|       |    public func image(withCompositingOperation compositingOperation: NSCompositingOperation,
  383|       |                      alpha: CGFloat = 1.0,
  384|       |                      backgroundColor: Color? = nil) -> Image
  385|       |    {
  386|       |        guard let cgImage = cgImage else {
  387|       |            assertionFailure("[Kingfisher] Compositing Operation image only works for CG-based image.")
  388|       |            return base
  389|       |        }
  390|       |
  391|       |        let rect = CGRect(origin: .zero, size: size)
  392|       |        return draw(cgImage: cgImage, to: rect.size) {
  393|       |            if let backgroundColor = backgroundColor {
  394|       |                backgroundColor.setFill()
  395|       |                rect.fill()
  396|       |            }
  397|       |
  398|       |            base.draw(in: rect, from: NSRect.zero, operation: compositingOperation, fraction: alpha)
  399|       |        }
  400|       |    }
  401|       |    #endif
  402|       |
  403|       |    // MARK: - Round Corner
  404|       |    /// Create a round corner image based on `self`.
  405|       |    ///
  406|       |    /// - parameter radius:          The round corner radius of creating image.
  407|       |    /// - parameter size:            The target size of creating image.
  408|       |    /// - parameter corners:         The target corners which will be applied rounding.
  409|       |    /// - parameter backgroundColor: The background color for the output image
  410|       |    ///
  411|       |    /// - returns: An image with round corner of `self`.
  412|       |    ///
  413|       |    /// - Note: This method only works for CG-based image.
  414|       |    public func image(withRoundRadius radius: CGFloat,
  415|       |                      fit size: CGSize,
  416|       |                      roundingCorners corners: RectCorner = .all,
  417|       |                      backgroundColor: Color? = nil) -> Image
  418|      0|    {   
  419|      0|        guard let cgImage = cgImage else {
  420|      0|            assertionFailure("[Kingfisher] Round corner image only works for CG-based image.")
  421|      0|            return base
  422|      0|        }
  423|      0|        
  424|      0|        let rect = CGRect(origin: CGPoint(x: 0, y: 0), size: size)
  425|      0|        return draw(cgImage: cgImage, to: size) {
  426|      0|            #if os(macOS)
  427|      0|                if let backgroundColor = backgroundColor {
  428|      0|                    let rectPath = NSBezierPath(rect: rect)
  429|      0|                    backgroundColor.setFill()
  430|      0|                    rectPath.fill()
  431|      0|                }
  432|      0|
  433|      0|                let path = NSBezierPath(roundedRect: rect, byRoundingCorners: corners, radius: radius)
  434|      0|                path.windingRule = .evenOddWindingRule
  435|      0|                path.addClip()
  436|      0|                base.draw(in: rect)
  437|      0|            #else
  438|      0|                guard let context = UIGraphicsGetCurrentContext() else {
  439|      0|                    assertionFailure("[Kingfisher] Failed to create CG context for image.")
  440|      0|                    return
  441|      0|                }
  442|      0|
  443|      0|                if let backgroundColor = backgroundColor {
  444|      0|                    let rectPath = UIBezierPath(rect: rect)
  445|      0|                    backgroundColor.setFill()
  446|      0|                    rectPath.fill()
  447|      0|                }
  448|      0|
  449|      0|                let path = UIBezierPath(roundedRect: rect,
  450|      0|                                        byRoundingCorners: corners.uiRectCorner,
  451|      0|                                        cornerRadii: CGSize(width: radius, height: radius)).cgPath
  452|      0|                context.addPath(path)
  453|      0|                context.clip()
  454|      0|                base.draw(in: rect)
  455|      0|            #endif
  456|      0|        }
  457|      0|    }
  458|       |    
  459|       |    #if os(iOS) || os(tvOS)
  460|      0|    func resize(to size: CGSize, for contentMode: UIViewContentMode) -> Image {
  461|      0|        switch contentMode {
  462|      0|        case .scaleAspectFit:
  463|      0|            return resize(to: size, for: .aspectFit)
  464|      0|        case .scaleAspectFill:
  465|      0|            return resize(to: size, for: .aspectFill)
  466|      0|        default:
  467|      0|            return resize(to: size)
  468|      0|        }
  469|      0|    }
  470|       |    #endif
  471|       |    
  472|       |    // MARK: - Resize
  473|       |    /// Resize `self` to an image of new size.
  474|       |    ///
  475|       |    /// - parameter size: The target size.
  476|       |    ///
  477|       |    /// - returns: An image with new size.
  478|       |    ///
  479|       |    /// - Note: This method only works for CG-based image.
  480|       |    public func resize(to size: CGSize) -> Image {
  481|       |        
  482|       |        guard let cgImage = cgImage else {
  483|      0|            assertionFailure("[Kingfisher] Resize only works for CG-based image.")
  484|       |            return base
  485|       |        }
  486|       |        
  487|       |        let rect = CGRect(origin: CGPoint(x: 0, y: 0), size: size)
  488|      0|        return draw(cgImage: cgImage, to: size) {
  489|      0|            #if os(macOS)
  490|      0|                base.draw(in: rect, from: NSRect.zero, operation: .copy, fraction: 1.0)
  491|      0|            #else
  492|      0|                base.draw(in: rect)
  493|      0|            #endif
  494|      0|        }
  495|       |    }
  496|       |    
  497|       |    /// Resize `self` to an image of new size, respecting the content mode.
  498|       |    ///
  499|       |    /// - Parameters:
  500|       |    ///   - size: The target size.
  501|       |    ///   - contentMode: Content mode of output image should be.
  502|       |    /// - Returns: An image with new size.
  503|       |    public func resize(to size: CGSize, for contentMode: ContentMode) -> Image {
  504|       |        switch contentMode {
  505|       |        case .aspectFit:
  506|       |            let newSize = self.size.kf.constrained(size)
  507|       |            return resize(to: newSize)
  508|       |        case .aspectFill:
  509|       |            let newSize = self.size.kf.filling(size)
  510|       |            return resize(to: newSize)
  511|       |        default:
  512|       |            return resize(to: size)
  513|       |        }
  514|       |    }
  515|       |    
  516|      0|    public func crop(to size: CGSize, anchorOn anchor: CGPoint) -> Image {
  517|      0|        guard let cgImage = cgImage else {
  518|      0|            assertionFailure("[Kingfisher] Crop only works for CG-based image.")
  519|      0|            return base
  520|      0|        }
  521|      0|        
  522|      0|        let rect = self.size.kf.constrainedRect(for: size, anchor: anchor)
  523|      0|        guard let image = cgImage.cropping(to: rect.scaled(scale)) else {
  524|      0|            assertionFailure("[Kingfisher] Cropping image failed.")
  525|      0|            return base
  526|      0|        }
  527|      0|        
  528|      0|        return Kingfisher.image(cgImage: image, scale: scale, refImage: base)
  529|      0|    }
  530|       |    
  531|       |    // MARK: - Blur
  532|       |    
  533|       |    /// Create an image with blur effect based on `self`.
  534|       |    ///
  535|       |    /// - parameter radius: The blur radius should be used when creating blur effect.
  536|       |    ///
  537|       |    /// - returns: An image with blur effect applied.
  538|       |    ///
  539|       |    /// - Note: This method only works for CG-based image.
  540|      0|    public func blurred(withRadius radius: CGFloat) -> Image {
  541|      0|        #if os(watchOS)
  542|      0|            return base
  543|      0|        #else
  544|      0|            guard let cgImage = cgImage else {
  545|      0|                assertionFailure("[Kingfisher] Blur only works for CG-based image.")
  546|      0|                return base
  547|      0|            }
  548|      0|            
  549|      0|            // http://www.w3.org/TR/SVG/filters.html#feGaussianBlurElement
  550|      0|            // let d = floor(s * 3*sqrt(2*pi)/4 + 0.5)
  551|      0|            // if d is odd, use three box-blurs of size 'd', centered on the output pixel.
  552|      0|            let s = Float(max(radius, 2.0))
  553|      0|            // We will do blur on a resized image (*0.5), so the blur radius could be half as well.
  554|      0|            
  555|      0|            // Fix the slow compiling time for Swift 3. 
  556|      0|            // See https://github.com/onevcat/Kingfisher/issues/611
  557|      0|            let pi2 = 2 * Float.pi
  558|      0|            let sqrtPi2 = sqrt(pi2)
  559|      0|            var targetRadius = floor(s * 3.0 * sqrtPi2 / 4.0 + 0.5)
  560|      0|            
  561|      0|            if targetRadius.isEven {
  562|      0|                targetRadius += 1
  563|      0|            }
  564|      0|            
  565|      0|            let iterations: Int
  566|      0|            if radius < 0.5 {
  567|      0|                iterations = 1
  568|      0|            } else if radius < 1.5 {
  569|      0|                iterations = 2
  570|      0|            } else {
  571|      0|                iterations = 3
  572|      0|            }
  573|      0|            
  574|      0|            let w = Int(size.width)
  575|      0|            let h = Int(size.height)
  576|      0|            let rowBytes = Int(CGFloat(cgImage.bytesPerRow))
  577|      0|            
  578|      0|            func createEffectBuffer(_ context: CGContext) -> vImage_Buffer {
  579|      0|                let data = context.data
  580|      0|                let width = vImagePixelCount(context.width)
  581|      0|                let height = vImagePixelCount(context.height)
  582|      0|                let rowBytes = context.bytesPerRow
  583|      0|                
  584|      0|                return vImage_Buffer(data: data, height: height, width: width, rowBytes: rowBytes)
  585|      0|            }
  586|      0|
  587|      0|            guard let context = beginContext(size: size, scale: scale) else {
  588|      0|                assertionFailure("[Kingfisher] Failed to create CG context for blurring image.")
  589|      0|                return base
  590|      0|            }
  591|      0|            defer { endContext() }
  592|      0|
  593|      0|            context.draw(cgImage, in: CGRect(x: 0, y: 0, width: w, height: h))
  594|      0|            
  595|      0|            var inBuffer = createEffectBuffer(context)
  596|      0|            
  597|      0|            guard let outContext = beginContext(size: size, scale: scale) else {
  598|      0|                assertionFailure("[Kingfisher] Failed to create CG context for blurring image.")
  599|      0|                return base
  600|      0|            }
  601|      0|            defer { endContext() }
  602|      0|            var outBuffer = createEffectBuffer(outContext)
  603|      0|            
  604|      0|            for _ in 0 ..< iterations {
  605|      0|                vImageBoxConvolve_ARGB8888(&inBuffer, &outBuffer, nil, 0, 0, UInt32(targetRadius), UInt32(targetRadius), nil, vImage_Flags(kvImageEdgeExtend))
  606|      0|                (inBuffer, outBuffer) = (outBuffer, inBuffer)
  607|      0|            }
  608|      0|            
  609|      0|            #if os(macOS)
  610|      0|                let result = outContext.makeImage().flatMap { fixedForRetinaPixel(cgImage: $0, to: size) }
  611|      0|            #else
  612|      0|                let result = outContext.makeImage().flatMap { Image(cgImage: $0, scale: base.scale, orientation: base.imageOrientation) }
  613|      0|            #endif
  614|      0|            guard let blurredImage = result else {
  615|      0|                assertionFailure("[Kingfisher] Can not make an blurred image within this context.")
  616|      0|                return base
  617|      0|            }
  618|      0|            
  619|      0|            return blurredImage
  620|      0|        #endif
  621|      0|    }
  622|       |    
  623|       |    // MARK: - Overlay
  624|       |    
  625|       |    /// Create an image from `self` with a color overlay layer.
  626|       |    ///
  627|       |    /// - parameter color:    The color should be use to overlay.
  628|       |    /// - parameter fraction: Fraction of input color. From 0.0 to 1.0. 0.0 means solid color, 1.0 means transparent overlay.
  629|       |    ///
  630|       |    /// - returns: An image with a color overlay applied.
  631|       |    ///
  632|       |    /// - Note: This method only works for CG-based image.
  633|      0|    public func overlaying(with color: Color, fraction: CGFloat) -> Image {
  634|      0|        
  635|      0|        guard let cgImage = cgImage else {
  636|      0|            assertionFailure("[Kingfisher] Overlaying only works for CG-based image.")
  637|      0|            return base
  638|      0|        }
  639|      0|        
  640|      0|        let rect = CGRect(x: 0, y: 0, width: size.width, height: size.height)
  641|      0|        return draw(cgImage: cgImage, to: rect.size) {
  642|      0|            #if os(macOS)
  643|      0|                base.draw(in: rect)
  644|      0|                if fraction > 0 {
  645|      0|                    color.withAlphaComponent(1 - fraction).set()
  646|      0|                    rect.fill(using: .sourceAtop)
  647|      0|                }
  648|      0|            #else
  649|      0|                color.set()
  650|      0|                UIRectFill(rect)
  651|      0|                base.draw(in: rect, blendMode: .destinationIn, alpha: 1.0)
  652|      0|                
  653|      0|                if fraction > 0 {
  654|      0|                    base.draw(in: rect, blendMode: .sourceAtop, alpha: fraction)
  655|      0|                }
  656|      0|            #endif
  657|      0|        }
  658|      0|    }
  659|       |    
  660|       |    // MARK: - Tint
  661|       |    
  662|       |    /// Create an image from `self` with a color tint.
  663|       |    ///
  664|       |    /// - parameter color: The color should be used to tint `self`
  665|       |    ///
  666|       |    /// - returns: An image with a color tint applied.
  667|      0|    public func tinted(with color: Color) -> Image {
  668|      0|        #if os(watchOS)
  669|      0|            return base
  670|      0|        #else
  671|      0|            return apply(.tint(color))
  672|      0|        #endif
  673|      0|    }
  674|       |    
  675|       |    // MARK: - Color Control
  676|       |    
  677|       |    /// Create an image from `self` with color control.
  678|       |    ///
  679|       |    /// - parameter brightness: Brightness changing to image.
  680|       |    /// - parameter contrast:   Contrast changing to image.
  681|       |    /// - parameter saturation: Saturation changing to image.
  682|       |    /// - parameter inputEV:    InputEV changing to image.
  683|       |    ///
  684|       |    /// - returns: An image with color control applied.
  685|      0|    public func adjusted(brightness: CGFloat, contrast: CGFloat, saturation: CGFloat, inputEV: CGFloat) -> Image {
  686|      0|        #if os(watchOS)
  687|      0|            return base
  688|      0|        #else
  689|      0|            return apply(.colorControl((brightness, contrast, saturation, inputEV)))
  690|      0|        #endif
  691|      0|    }
  692|       |
  693|       |    /// Return an image with given scale.
  694|       |    ///
  695|       |    /// - Parameter scale: Target scale factor the new image should have.
  696|       |    /// - Returns: The image with target scale. If the base image is already in the scale, `base` will be returned.
  697|      0|    public func scaled(to scale: CGFloat) -> Image {
  698|      0|        guard scale != self.scale else {
  699|      0|            return base
  700|      0|        }
  701|      0|        guard let cgImage = cgImage else {
  702|      0|            assertionFailure("[Kingfisher] Scaling only works for CG-based image.")
  703|      0|            return base
  704|      0|        }
  705|      0|        return Kingfisher.image(cgImage: cgImage, scale: scale, refImage: base)
  706|      0|    }
  707|       |}
  708|       |
  709|       |// MARK: - Decode
  710|       |extension Kingfisher where Base: Image {
  711|      0|    var decoded: Image {
  712|      0|        return decoded(scale: scale)
  713|      0|    }
  714|       |    
  715|       |    func decoded(scale: CGFloat) -> Image {
  716|       |        // prevent animated image (GIF) lose it's images
  717|       |        #if os(iOS)
  718|       |            if imageSource != nil { return base }
  719|       |        #else
  720|       |            if images != nil { return base }
  721|       |        #endif
  722|       |        
  723|       |        guard let imageRef = self.cgImage else {
  724|      0|            assertionFailure("[Kingfisher] Decoding only works for CG-based image.")
  725|       |            return base
  726|       |        }
  727|       |        
  728|       |        // Draw CGImage in a plain context with scale of 1.0.
  729|       |        guard let context = beginContext(size: CGSize(width: imageRef.width, height: imageRef.height), scale: 1.0) else {
  730|      0|            assertionFailure("[Kingfisher] Decoding fails to create a valid context.")
  731|       |            return base
  732|       |        }
  733|       |        
  734|       |        defer { endContext() }
  735|       |        
  736|       |        let rect = CGRect(x: 0, y: 0, width: CGFloat(imageRef.width), height: CGFloat(imageRef.height))
  737|       |        context.draw(imageRef, in: rect)
  738|       |        let decompressedImageRef = context.makeImage()
  739|       |        return Kingfisher<Image>.image(cgImage: decompressedImageRef!, scale: scale, refImage: base)
  740|       |    }
  741|       |}
  742|       |
  743|       |/// Reference the source image reference
  744|       |final class ImageSource {
  745|       |    var imageRef: CGImageSource?
  746|      0|    init(ref: CGImageSource) {
  747|      0|        self.imageRef = ref
  748|      0|    }
  749|       |}
  750|       |
  751|       |// MARK: - Image format
  752|       |private struct ImageHeaderData {
  753|       |    static var PNG: [UInt8] = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]
  754|       |    static var JPEG_SOI: [UInt8] = [0xFF, 0xD8]
  755|       |    static var JPEG_IF: [UInt8] = [0xFF]
  756|       |    static var GIF: [UInt8] = [0x47, 0x49, 0x46]
  757|       |}
  758|       |
  759|       |enum ImageFormat {
  760|       |    case unknown, PNG, JPEG, GIF
  761|       |}
  762|       |
  763|       |
  764|       |// MARK: - Misc Helpers
  765|       |public struct DataProxy {
  766|       |    fileprivate let base: Data
  767|      0|    init(proxy: Data) {
  768|      0|        base = proxy
  769|      0|    }
  770|       |}
  771|       |
  772|       |extension Data: KingfisherCompatible {
  773|       |    public typealias CompatibleType = DataProxy
  774|       |    public var kf: DataProxy {
  775|       |        return DataProxy(proxy: self)
  776|       |    }
  777|       |}
  778|       |
  779|       |extension DataProxy {
  780|       |    var imageFormat: ImageFormat {
  781|       |        var buffer = [UInt8](repeating: 0, count: 8)
  782|       |        (base as NSData).getBytes(&buffer, length: 8)
  783|       |        if buffer == ImageHeaderData.PNG {
  784|       |            return .PNG
  785|       |        } else if buffer[0] == ImageHeaderData.JPEG_SOI[0] &&
  786|      0|            buffer[1] == ImageHeaderData.JPEG_SOI[1] &&
  787|      0|            buffer[2] == ImageHeaderData.JPEG_IF[0]
  788|       |        {
  789|       |            return .JPEG
  790|       |        } else if buffer[0] == ImageHeaderData.GIF[0] &&
  791|      0|            buffer[1] == ImageHeaderData.GIF[1] &&
  792|      0|            buffer[2] == ImageHeaderData.GIF[2]
  793|       |        {
  794|       |            return .GIF
  795|       |        }
  796|       |
  797|       |        return .unknown
  798|       |    }
  799|       |}
  800|       |
  801|       |public struct CGSizeProxy {
  802|       |    fileprivate let base: CGSize
  803|      0|    init(proxy: CGSize) {
  804|      0|        base = proxy
  805|      0|    }
  806|       |}
  807|       |
  808|       |extension CGSize: KingfisherCompatible {
  809|       |    public typealias CompatibleType = CGSizeProxy
  810|       |    public var kf: CGSizeProxy {
  811|       |        return CGSizeProxy(proxy: self)
  812|       |    }
  813|       |}
  814|       |
  815|       |extension CGSizeProxy {
  816|       |    func constrained(_ size: CGSize) -> CGSize {
  817|       |        let aspectWidth = round(aspectRatio * size.height)
  818|       |        let aspectHeight = round(size.width / aspectRatio)
  819|       |
  820|       |        return aspectWidth > size.width ? CGSize(width: size.width, height: aspectHeight) : CGSize(width: aspectWidth, height: size.height)
  821|       |    }
  822|       |
  823|       |    func filling(_ size: CGSize) -> CGSize {
  824|       |        let aspectWidth = round(aspectRatio * size.height)
  825|       |        let aspectHeight = round(size.width / aspectRatio)
  826|       |
  827|       |        return aspectWidth < size.width ? CGSize(width: size.width, height: aspectHeight) : CGSize(width: aspectWidth, height: size.height)
  828|       |    }
  829|       |
  830|       |    private var aspectRatio: CGFloat {
  831|       |        return base.height == 0.0 ? 1.0 : base.width / base.height
  832|       |    }
  833|       |    
  834|       |    
  835|       |    func constrainedRect(for size: CGSize, anchor: CGPoint) -> CGRect {
  836|       |        
  837|       |        let unifiedAnchor = CGPoint(x: anchor.x.clamped(to: 0.0...1.0),
  838|       |                                    y: anchor.y.clamped(to: 0.0...1.0))
  839|       |        
  840|       |        let x = unifiedAnchor.x * base.width - unifiedAnchor.x * size.width
  841|       |        let y = unifiedAnchor.y * base.height - unifiedAnchor.y * size.height
  842|       |        let r = CGRect(x: x, y: y, width: size.width, height: size.height)
  843|       |        
  844|       |        let ori = CGRect(origin: CGPoint.zero, size: base)
  845|       |        return ori.intersection(r)
  846|       |    }
  847|       |}
  848|       |
  849|       |extension CGRect {
  850|       |    func scaled(_ scale: CGFloat) -> CGRect {
  851|       |        return CGRect(x: origin.x * scale, y: origin.y * scale,
  852|       |                      width: size.width * scale, height: size.height * scale)
  853|       |    }
  854|       |}
  855|       |
  856|       |extension Comparable {
  857|       |    func clamped(to limits: ClosedRange<Self>) -> Self {
  858|       |        return min(max(self, limits.lowerBound), limits.upperBound)
  859|       |    }
  860|       |}
  861|       |
  862|       |extension Kingfisher where Base: Image {
  863|       |    
  864|       |    func beginContext(size: CGSize, scale: CGFloat) -> CGContext? {
  865|       |        #if os(macOS)
  866|       |            guard let rep = NSBitmapImageRep(
  867|       |                bitmapDataPlanes: nil,
  868|       |                pixelsWide: Int(size.width),
  869|       |                pixelsHigh: Int(size.height),
  870|       |                bitsPerSample: cgImage?.bitsPerComponent ?? 8,
  871|       |                samplesPerPixel: 4,
  872|       |                hasAlpha: true,
  873|       |                isPlanar: false,
  874|       |                colorSpaceName: .calibratedRGB,
  875|       |                bytesPerRow: 0,
  876|       |                bitsPerPixel: 0) else
  877|       |            {
  878|       |                assertionFailure("[Kingfisher] Image representation cannot be created.")
  879|       |                return nil
  880|       |            }
  881|       |            rep.size = size
  882|       |            NSGraphicsContext.saveGraphicsState()
  883|       |            guard let context = NSGraphicsContext(bitmapImageRep: rep) else {
  884|       |                assertionFailure("[Kingfisher] Image contenxt cannot be created.")
  885|       |                return nil
  886|       |            }
  887|       |            
  888|       |            NSGraphicsContext.current = context
  889|       |            return context.cgContext
  890|       |        #else
  891|       |            UIGraphicsBeginImageContextWithOptions(size, false, scale)
  892|       |            let context = UIGraphicsGetCurrentContext()
  893|       |            context?.scaleBy(x: 1.0, y: -1.0)
  894|       |            context?.translateBy(x: 0, y: -size.height)
  895|       |            return context
  896|       |        #endif
  897|       |    }
  898|       |    
  899|      0|    func endContext() {
  900|      0|        #if os(macOS)
  901|      0|            NSGraphicsContext.restoreGraphicsState()
  902|      0|        #else
  903|      0|            UIGraphicsEndImageContext()
  904|      0|        #endif
  905|      0|    }
  906|       |    
  907|       |    func draw(cgImage: CGImage?, to size: CGSize, draw: ()->()) -> Image {
  908|       |        #if os(macOS)
  909|       |        guard let rep = NSBitmapImageRep(
  910|       |            bitmapDataPlanes: nil,
  911|       |            pixelsWide: Int(size.width),
  912|       |            pixelsHigh: Int(size.height),
  913|       |            bitsPerSample: cgImage?.bitsPerComponent ?? 8,
  914|       |            samplesPerPixel: 4,
  915|       |            hasAlpha: true,
  916|       |            isPlanar: false,
  917|       |            colorSpaceName: .calibratedRGB,
  918|       |            bytesPerRow: 0,
  919|       |            bitsPerPixel: 0) else
  920|       |        {
  921|       |            assertionFailure("[Kingfisher] Image representation cannot be created.")
  922|       |            return base
  923|       |        }
  924|       |        rep.size = size
  925|       |        
  926|       |        NSGraphicsContext.saveGraphicsState()
  927|       |        
  928|       |        let context = NSGraphicsContext(bitmapImageRep: rep)
  929|       |        NSGraphicsContext.current = context
  930|       |        draw()
  931|       |        NSGraphicsContext.restoreGraphicsState()
  932|       |        
  933|       |        let outputImage = Image(size: size)
  934|       |        outputImage.addRepresentation(rep)
  935|       |        return outputImage
  936|       |        #else
  937|       |            
  938|       |        UIGraphicsBeginImageContextWithOptions(size, false, scale)
  939|       |        defer { UIGraphicsEndImageContext() }
  940|       |        draw()
  941|      0|        return UIGraphicsGetImageFromCurrentImageContext() ?? base
  942|       |        
  943|       |        #endif
  944|       |    }
  945|       |    
  946|       |    #if os(macOS)
  947|       |    func fixedForRetinaPixel(cgImage: CGImage, to size: CGSize) -> Image {
  948|       |        
  949|       |        let image = Image(cgImage: cgImage, size: base.size)
  950|       |        let rect = CGRect(origin: CGPoint(x: 0, y: 0), size: size)
  951|       |        
  952|       |        return draw(cgImage: cgImage, to: self.size) {
  953|       |            image.draw(in: rect, from: NSRect.zero, operation: .copy, fraction: 1.0)
  954|       |        }
  955|       |    }
  956|       |    #endif
  957|       |}
  958|       |
  959|       |extension Float {
  960|       |    var isEven: Bool {
  961|       |        return truncatingRemainder(dividingBy: 2.0) == 0
  962|       |    }
  963|       |}
  964|       |
  965|       |#if os(macOS)
  966|       |extension NSBezierPath {
  967|       |    convenience init(roundedRect rect: NSRect, topLeftRadius: CGFloat, topRightRadius: CGFloat,
  968|       |         bottomLeftRadius: CGFloat, bottomRightRadius: CGFloat)
  969|       |    {
  970|       |        self.init()
  971|       |        
  972|       |        let maxCorner = min(rect.width, rect.height) / 2
  973|       |        
  974|       |        let radiusTopLeft = min(maxCorner, max(0, topLeftRadius))
  975|       |        let radiusTopRight = min(maxCorner, max(0, topRightRadius))
  976|       |        let radiusBottomLeft = min(maxCorner, max(0, bottomLeftRadius))
  977|       |        let radiusBottomRight = min(maxCorner, max(0, bottomRightRadius))
  978|       |        
  979|       |        guard !NSIsEmptyRect(rect) else {
  980|       |            return
  981|       |        }
  982|       |        
  983|       |        let topLeft = NSMakePoint(NSMinX(rect), NSMaxY(rect));
  984|       |        let topRight = NSMakePoint(NSMaxX(rect), NSMaxY(rect));
  985|       |        let bottomRight = NSMakePoint(NSMaxX(rect), NSMinY(rect));
  986|       |        
  987|       |        move(to: NSMakePoint(NSMidX(rect), NSMaxY(rect)))
  988|       |        appendArc(from: topLeft, to: rect.origin, radius: radiusTopLeft)
  989|       |        appendArc(from: rect.origin, to: bottomRight, radius: radiusBottomLeft)
  990|       |        appendArc(from: bottomRight, to: topRight, radius: radiusBottomRight)
  991|       |        appendArc(from: topRight, to: topLeft, radius: radiusTopRight)
  992|       |        close()
  993|       |    }
  994|       |    
  995|       |    convenience init(roundedRect rect: NSRect, byRoundingCorners corners: RectCorner, radius: CGFloat) {
  996|       |        let radiusTopLeft = corners.contains(.topLeft) ? radius : 0
  997|       |        let radiusTopRight = corners.contains(.topRight) ? radius : 0
  998|       |        let radiusBottomLeft = corners.contains(.bottomLeft) ? radius : 0
  999|       |        let radiusBottomRight = corners.contains(.bottomRight) ? radius : 0
 1000|       |        
 1001|       |        self.init(roundedRect: rect, topLeftRadius: radiusTopLeft, topRightRadius: radiusTopRight,
 1002|       |                  bottomLeftRadius: radiusBottomLeft, bottomRightRadius: radiusBottomRight)
 1003|       |    }
 1004|       |}
 1005|       |    
 1006|       |#else
 1007|       |extension RectCorner {
 1008|       |    var uiRectCorner: UIRectCorner {
 1009|       |        
 1010|       |        var result: UIRectCorner = []
 1011|       |        
 1012|       |        if self.contains(.topLeft) { result.insert(.topLeft) }
 1013|       |        if self.contains(.topRight) { result.insert(.topRight) }
 1014|       |        if self.contains(.bottomLeft) { result.insert(.bottomLeft) }
 1015|       |        if self.contains(.bottomRight) { result.insert(.bottomRight) }
 1016|       |        
 1017|       |        return result
 1018|       |    }
 1019|       |}
 1020|       |#endif
 1021|       |

/Users/raduj/Developer/Appub/Pods/Kingfisher/Sources/ImageCache.swift:
    1|       |//
    2|       |//  ImageCache.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 15/4/6.
    6|       |//
    7|       |//  Copyright (c) 2018 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |#if os(macOS)
   28|       |import AppKit
   29|       |#else
   30|       |import UIKit
   31|       |#endif
   32|       |
   33|       |extension Notification.Name {
   34|       |    /**
   35|       |     This notification will be sent when the disk cache got cleaned either there are cached files expired or the total size exceeding the max allowed size. The manually invoking of `clearDiskCache` method will not trigger this notification.
   36|       |     
   37|       |     The `object` of this notification is the `ImageCache` object which sends the notification.
   38|       |     
   39|       |     A list of removed hashes (files) could be retrieved by accessing the array under `KingfisherDiskCacheCleanedHashKey` key in `userInfo` of the notification object you received. By checking the array, you could know the hash codes of files are removed.
   40|       |     
   41|       |     The main purpose of this notification is supplying a chance to maintain some necessary information on the cached files. See [this wiki](https://github.com/onevcat/Kingfisher/wiki/How-to-implement-ETag-based-304-(Not-Modified)-handling-in-Kingfisher) for a use case on it.
   42|       |     */
   43|       |    public static let KingfisherDidCleanDiskCache = Notification.Name.init("com.onevcat.Kingfisher.KingfisherDidCleanDiskCache")
   44|       |}
   45|       |
   46|       |/**
   47|       |Key for array of cleaned hashes in `userInfo` of `KingfisherDidCleanDiskCacheNotification`.
   48|       |*/
   49|       |public let KingfisherDiskCacheCleanedHashKey = "com.onevcat.Kingfisher.cleanedHash"
   50|       |
   51|       |/// It represents a task of retrieving image. You can call `cancel` on it to stop the process.
   52|       |public typealias RetrieveImageDiskTask = DispatchWorkItem
   53|       |
   54|       |/**
   55|       |Cache type of a cached image.
   56|       |
   57|       |- None:   The image is not cached yet when retrieving it.
   58|       |- Memory: The image is cached in memory.
   59|       |- Disk:   The image is cached in disk.
   60|       |*/
   61|       |public enum CacheType {
   62|       |    case none, memory, disk
   63|       |    
   64|      0|    public var cached: Bool {
   65|      0|        switch self {
   66|      0|        case .memory, .disk: return true
   67|      0|        case .none: return false
   68|      0|        }
   69|      0|    }
   70|       |}
   71|       |
   72|       |/// `ImageCache` represents both the memory and disk cache system of Kingfisher. 
   73|       |/// While a default image cache object will be used if you prefer the extension methods of Kingfisher, 
   74|       |/// you can create your own cache object and configure it as your need. You could use an `ImageCache`
   75|       |/// object to manipulate memory and disk cache for Kingfisher.
   76|       |open class ImageCache {
   77|       |
   78|       |    //Memory
   79|       |    fileprivate let memoryCache = NSCache<NSString, AnyObject>()
   80|       |    
   81|       |    /// The largest cache cost of memory cache. The total cost is pixel count of 
   82|       |    /// all cached images in memory.
   83|       |    /// Default is unlimited. Memory cache will be purged automatically when a 
   84|       |    /// memory warning notification is received.
   85|       |    open var maxMemoryCost: UInt = 0 {
   86|      0|        didSet {
   87|      0|            self.memoryCache.totalCostLimit = Int(maxMemoryCost)
   88|      0|        }
   89|       |    }
   90|       |    
   91|       |    //Disk
   92|       |    fileprivate let ioQueue: DispatchQueue
   93|       |    fileprivate var fileManager: FileManager!
   94|       |    
   95|       |    ///The disk cache location.
   96|       |    open let diskCachePath: String
   97|       |  
   98|       |    /// The default file extension appended to cached files.
   99|       |    open var pathExtension: String?
  100|       |    
  101|       |    /// The longest time duration in second of the cache being stored in disk. 
  102|       |    /// Default is 1 week (60 * 60 * 24 * 7 seconds).
  103|       |    /// Setting this to a negative value will make the disk cache never expiring.
  104|       |    open var maxCachePeriodInSecond: TimeInterval = 60 * 60 * 24 * 7 //Cache exists for 1 week
  105|       |    
  106|       |    /// The largest disk size can be taken for the cache. It is the total 
  107|       |    /// allocated size of cached files in bytes.
  108|       |    /// Default is no limit.
  109|       |    open var maxDiskCacheSize: UInt = 0
  110|       |    
  111|       |    fileprivate let processQueue: DispatchQueue
  112|       |    
  113|       |    /// The default cache.
  114|       |    public static let `default` = ImageCache(name: "default")
  115|       |    
  116|       |    /// Closure that defines the disk cache path from a given path and cacheName.
  117|       |    public typealias DiskCachePathClosure = (String?, String) -> String
  118|       |    
  119|       |    /// The default DiskCachePathClosure
  120|      0|    public final class func defaultDiskCachePathClosure(path: String?, cacheName: String) -> String {
  121|      0|        let dstPath = path ?? NSSearchPathForDirectoriesInDomains(.cachesDirectory, .userDomainMask, true).first!
  122|      0|        return (dstPath as NSString).appendingPathComponent(cacheName)
  123|      0|    }
  124|       |    
  125|       |    /**
  126|       |    Init method. Passing a name for the cache. It represents a cache folder in the memory and disk.
  127|       |    
  128|       |    - parameter name: Name of the cache. It will be used as the memory cache name and the disk cache folder name 
  129|       |                      appending to the cache path. This value should not be an empty string.
  130|       |    - parameter path: Optional - Location of cache path on disk. If `nil` is passed in (the default value),
  131|       |                      the `.cachesDirectory` in of your app will be used.
  132|       |    - parameter diskCachePathClosure: Closure that takes in an optional initial path string and generates
  133|       |                      the final disk cache path. You could use it to fully customize your cache path.
  134|       |    
  135|       |    - returns: The cache object.
  136|       |    */
  137|       |    public init(name: String,
  138|       |                path: String? = nil,
  139|       |                diskCachePathClosure: DiskCachePathClosure = ImageCache.defaultDiskCachePathClosure)
  140|      0|    {
  141|      0|        
  142|      0|        if name.isEmpty {
  143|      0|            fatalError("[Kingfisher] You should specify a name for the cache. A cache with empty name is not permitted.")
  144|      0|        }
  145|      0|        
  146|      0|        let cacheName = "com.onevcat.Kingfisher.ImageCache.\(name)"
  147|      0|        memoryCache.name = cacheName
  148|      0|        
  149|      0|        diskCachePath = diskCachePathClosure(path, cacheName)
  150|      0|        
  151|      0|        let ioQueueName = "com.onevcat.Kingfisher.ImageCache.ioQueue.\(name)"
  152|      0|        ioQueue = DispatchQueue(label: ioQueueName)
  153|      0|        
  154|      0|        let processQueueName = "com.onevcat.Kingfisher.ImageCache.processQueue.\(name)"
  155|      0|        processQueue = DispatchQueue(label: processQueueName, attributes: .concurrent)
  156|      0|        
  157|      0|        ioQueue.sync { fileManager = FileManager() }
  158|      0|        
  159|      0|#if !os(macOS) && !os(watchOS)
  160|      0|        NotificationCenter.default.addObserver(
  161|      0|            self, selector: #selector(clearMemoryCache), name: .UIApplicationDidReceiveMemoryWarning, object: nil)
  162|      0|        NotificationCenter.default.addObserver(
  163|      0|            self, selector: #selector(cleanExpiredDiskCache), name: .UIApplicationWillTerminate, object: nil)
  164|      0|        NotificationCenter.default.addObserver(
  165|      0|            self, selector: #selector(backgroundCleanExpiredDiskCache), name: .UIApplicationDidEnterBackground, object: nil)
  166|      0|#endif
  167|      0|    }
  168|       |    
  169|      0|    deinit {
  170|      0|        NotificationCenter.default.removeObserver(self)
  171|      0|    }
  172|       |
  173|       |
  174|       |    // MARK: - Store & Remove
  175|       |
  176|       |    /**
  177|       |    Store an image to cache. It will be saved to both memory and disk. It is an async operation.
  178|       |    
  179|       |    - parameter image:             The image to be stored.
  180|       |    - parameter original:          The original data of the image.
  181|       |                                   Kingfisher will use it to check the format of the image and optimize cache size on disk.
  182|       |                                   If `nil` is supplied, the image data will be saved as a normalized PNG file.
  183|       |                                   It is strongly suggested to supply it whenever possible, to get a better performance and disk usage.
  184|       |    - parameter key:               Key for the image.
  185|       |    - parameter identifier:        The identifier of processor used. If you are using a processor for the image, pass the identifier of
  186|       |                                   processor to it.
  187|       |                                   This identifier will be used to generate a corresponding key for the combination of `key` and processor.
  188|       |    - parameter toDisk:            Whether this image should be cached to disk or not. If false, the image will be only cached in memory.
  189|       |    - parameter completionHandler: Called when store operation completes.
  190|       |    */
  191|       |    open func store(_ image: Image,
  192|       |                      original: Data? = nil,
  193|       |                      forKey key: String,
  194|       |                      processorIdentifier identifier: String = "",
  195|       |                      cacheSerializer serializer: CacheSerializer = DefaultCacheSerializer.default,
  196|       |                      toDisk: Bool = true,
  197|       |                      completionHandler: (() -> Void)? = nil)
  198|      0|    {
  199|      0|        
  200|      0|        let computedKey = key.computedKey(with: identifier)
  201|      0|        memoryCache.setObject(image, forKey: computedKey as NSString, cost: image.kf.imageCost)
  202|      0|
  203|      0|        func callHandlerInMainQueue() {
  204|      0|            if let handler = completionHandler {
  205|      0|                DispatchQueue.main.async {
  206|      0|                    handler()
  207|      0|                }
  208|      0|            }
  209|      0|        }
  210|      0|        
  211|      0|        if toDisk {
  212|      0|            ioQueue.async {
  213|      0|                
  214|      0|                if let data = serializer.data(with: image, original: original) {
  215|      0|                    if !self.fileManager.fileExists(atPath: self.diskCachePath) {
  216|      0|                        do {
  217|      0|                            try self.fileManager.createDirectory(atPath: self.diskCachePath, withIntermediateDirectories: true, attributes: nil)
  218|      0|                        } catch _ {}
  219|      0|                    }
  220|      0|                    
  221|      0|                    self.fileManager.createFile(atPath: self.cachePath(forComputedKey: computedKey), contents: data, attributes: nil)
  222|      0|                }
  223|      0|                callHandlerInMainQueue()
  224|      0|            }
  225|      0|        } else {
  226|      0|            callHandlerInMainQueue()
  227|      0|        }
  228|      0|    }
  229|       |    
  230|       |    /**
  231|       |    Remove the image for key for the cache. It will be opted out from both memory and disk. 
  232|       |    It is an async operation.
  233|       |    
  234|       |    - parameter key:               Key for the image.
  235|       |    - parameter identifier:        The identifier of processor used. If you are using a processor for the image, pass the identifier of processor to it.
  236|       |                                   This identifier will be used to generate a corresponding key for the combination of `key` and processor.
  237|       |    - parameter fromMemory:        Whether this image should be removed from memory or not. If false, the image won't be removed from memory.
  238|       |    - parameter fromDisk:          Whether this image should be removed from disk or not. If false, the image won't be removed from disk.
  239|       |    - parameter completionHandler: Called when removal operation completes.
  240|       |    */
  241|       |    open func removeImage(forKey key: String,
  242|       |                          processorIdentifier identifier: String = "",
  243|       |                          fromMemory: Bool = true,
  244|       |                          fromDisk: Bool = true,
  245|       |                          completionHandler: (() -> Void)? = nil)
  246|      0|    {
  247|      0|        let computedKey = key.computedKey(with: identifier)
  248|      0|
  249|      0|        if fromMemory {
  250|      0|            memoryCache.removeObject(forKey: computedKey as NSString)
  251|      0|        }
  252|      0|        
  253|      0|        func callHandlerInMainQueue() {
  254|      0|            if let handler = completionHandler {
  255|      0|                DispatchQueue.main.async {
  256|      0|                    handler()
  257|      0|                }
  258|      0|            }
  259|      0|        }
  260|      0|        
  261|      0|        if fromDisk {
  262|      0|            ioQueue.async{
  263|      0|                do {
  264|      0|                    try self.fileManager.removeItem(atPath: self.cachePath(forComputedKey: computedKey))
  265|      0|                } catch _ {}
  266|      0|                callHandlerInMainQueue()
  267|      0|            }
  268|      0|        } else {
  269|      0|            callHandlerInMainQueue()
  270|      0|        }
  271|      0|    }
  272|       |
  273|       |    // MARK: - Get data from cache
  274|       |
  275|       |    /**
  276|       |    Get an image for a key from memory or disk.
  277|       |    
  278|       |    - parameter key:               Key for the image.
  279|       |    - parameter options:           Options of retrieving image. If you need to retrieve an image which was 
  280|       |                                   stored with a specified `ImageProcessor`, pass the processor in the option too.
  281|       |    - parameter completionHandler: Called when getting operation completes with image result and cached type of 
  282|       |                                   this image. If there is no such key cached, the image will be `nil`.
  283|       |    
  284|       |    - returns: The retrieving task.
  285|       |    */
  286|       |    @discardableResult
  287|       |    open func retrieveImage(forKey key: String,
  288|       |                               options: KingfisherOptionsInfo?,
  289|       |                     completionHandler: ((Image?, CacheType) -> Void)?) -> RetrieveImageDiskTask?
  290|      0|    {
  291|      0|        // No completion handler. Not start working and early return.
  292|      0|        guard let completionHandler = completionHandler else {
  293|      0|            return nil
  294|      0|        }
  295|      0|        
  296|      0|        var block: RetrieveImageDiskTask?
  297|      0|        let options = options ?? KingfisherEmptyOptionsInfo
  298|      0|        let imageModifier = options.imageModifier
  299|      0|
  300|      0|        if let image = self.retrieveImageInMemoryCache(forKey: key, options: options) {
  301|      0|            options.callbackDispatchQueue.safeAsync {
  302|      0|                completionHandler(imageModifier.modify(image), .memory)
  303|      0|            }
  304|      0|        } else if options.fromMemoryCacheOrRefresh { // Only allows to get images from memory cache.
  305|      0|            options.callbackDispatchQueue.safeAsync {
  306|      0|                completionHandler(nil, .none)
  307|      0|            }
  308|      0|        } else {
  309|      0|            var sSelf: ImageCache! = self
  310|      0|            block = DispatchWorkItem(block: {
  311|      0|                // Begin to load image from disk
  312|      0|                if let image = sSelf.retrieveImageInDiskCache(forKey: key, options: options) {
  313|      0|                    if options.backgroundDecode {
  314|      0|                        sSelf.processQueue.async {
  315|      0|
  316|      0|                            let result = image.kf.decoded
  317|      0|                            
  318|      0|                            sSelf.store(result,
  319|      0|                                        forKey: key,
  320|      0|                                        processorIdentifier: options.processor.identifier,
  321|      0|                                        cacheSerializer: options.cacheSerializer,
  322|      0|                                        toDisk: false,
  323|      0|                                        completionHandler: nil)
  324|      0|                            options.callbackDispatchQueue.safeAsync {
  325|      0|                                completionHandler(imageModifier.modify(result), .memory)
  326|      0|                                sSelf = nil
  327|      0|                            }
  328|      0|                        }
  329|      0|                    } else {
  330|      0|                        sSelf.store(image,
  331|      0|                                    forKey: key,
  332|      0|                                    processorIdentifier: options.processor.identifier,
  333|      0|                                    cacheSerializer: options.cacheSerializer,
  334|      0|                                    toDisk: false,
  335|      0|                                    completionHandler: nil
  336|      0|                        )
  337|      0|                        options.callbackDispatchQueue.safeAsync {
  338|      0|                            completionHandler(imageModifier.modify(image), .disk)
  339|      0|                            sSelf = nil
  340|      0|                        }
  341|      0|                    }
  342|      0|                } else {
  343|      0|                    // No image found from either memory or disk
  344|      0|                    options.callbackDispatchQueue.safeAsync {
  345|      0|                        completionHandler(nil, .none)
  346|      0|                        sSelf = nil
  347|      0|                    }
  348|      0|                }
  349|      0|            })
  350|      0|            
  351|      0|            sSelf.ioQueue.async(execute: block!)
  352|      0|        }
  353|      0|    
  354|      0|        return block
  355|      0|    }
  356|       |    
  357|       |    /**
  358|       |    Get an image for a key from memory.
  359|       |    
  360|       |    - parameter key:     Key for the image.
  361|       |    - parameter options: Options of retrieving image. If you need to retrieve an image which was 
  362|       |                         stored with a specified `ImageProcessor`, pass the processor in the option too.
  363|       |    - returns: The image object if it is cached, or `nil` if there is no such key in the cache.
  364|       |    */
  365|      0|    open func retrieveImageInMemoryCache(forKey key: String, options: KingfisherOptionsInfo? = nil) -> Image? {
  366|      0|        
  367|      0|        let options = options ?? KingfisherEmptyOptionsInfo
  368|      0|        let computedKey = key.computedKey(with: options.processor.identifier)
  369|      0|        
  370|      0|        return memoryCache.object(forKey: computedKey as NSString) as? Image
  371|      0|    }
  372|       |    
  373|       |    /**
  374|       |    Get an image for a key from disk.
  375|       |    
  376|       |    - parameter key:     Key for the image.
  377|       |    - parameter options: Options of retrieving image. If you need to retrieve an image which was
  378|       |                         stored with a specified `ImageProcessor`, pass the processor in the option too.
  379|       |
  380|       |    - returns: The image object if it is cached, or `nil` if there is no such key in the cache.
  381|       |    */
  382|      0|    open func retrieveImageInDiskCache(forKey key: String, options: KingfisherOptionsInfo? = nil) -> Image? {
  383|      0|        
  384|      0|        let options = options ?? KingfisherEmptyOptionsInfo
  385|      0|        let computedKey = key.computedKey(with: options.processor.identifier)
  386|      0|        
  387|      0|        return diskImage(forComputedKey: computedKey, serializer: options.cacheSerializer, options: options)
  388|      0|    }
  389|       |
  390|       |
  391|       |    // MARK: - Clear & Clean
  392|       |
  393|       |    /**
  394|       |    Clear memory cache.
  395|       |    */
  396|      0|    @objc public func clearMemoryCache() {
  397|      0|        memoryCache.removeAllObjects()
  398|      0|    }
  399|       |    
  400|       |    /**
  401|       |    Clear disk cache. This is an async operation.
  402|       |    
  403|       |    - parameter completionHander: Called after the operation completes.
  404|       |    */
  405|      0|    open func clearDiskCache(completion handler: (()->())? = nil) {
  406|      0|        ioQueue.async {
  407|      0|            do {
  408|      0|                try self.fileManager.removeItem(atPath: self.diskCachePath)
  409|      0|                try self.fileManager.createDirectory(atPath: self.diskCachePath, withIntermediateDirectories: true, attributes: nil)
  410|      0|            } catch _ { }
  411|      0|            
  412|      0|            if let handler = handler {
  413|      0|                DispatchQueue.main.async {
  414|      0|                    handler()
  415|      0|                }
  416|      0|            }
  417|      0|        }
  418|      0|    }
  419|       |    
  420|       |    /**
  421|       |    Clean expired disk cache. This is an async operation.
  422|       |    */
  423|      0|    @objc fileprivate func cleanExpiredDiskCache() {
  424|      0|        cleanExpiredDiskCache(completion: nil)
  425|      0|    }
  426|       |    
  427|       |    /**
  428|       |    Clean expired disk cache. This is an async operation.
  429|       |    
  430|       |    - parameter completionHandler: Called after the operation completes.
  431|       |    */
  432|      0|    open func cleanExpiredDiskCache(completion handler: (()->())? = nil) {
  433|      0|        
  434|      0|        // Do things in concurrent io queue
  435|      0|        ioQueue.async {
  436|      0|            
  437|      0|            var (URLsToDelete, diskCacheSize, cachedFiles) = self.travelCachedFiles(onlyForCacheSize: false)
  438|      0|            
  439|      0|            for fileURL in URLsToDelete {
  440|      0|                do {
  441|      0|                    try self.fileManager.removeItem(at: fileURL)
  442|      0|                } catch _ { }
  443|      0|            }
  444|      0|                
  445|      0|            if self.maxDiskCacheSize > 0 && diskCacheSize > self.maxDiskCacheSize {
  446|      0|                let targetSize = self.maxDiskCacheSize / 2
  447|      0|                    
  448|      0|                // Sort files by last modify date. We want to clean from the oldest files.
  449|      0|                let sortedFiles = cachedFiles.keysSortedByValue {
  450|      0|                    resourceValue1, resourceValue2 -> Bool in
  451|      0|                    
  452|      0|                    if let date1 = resourceValue1.contentAccessDate,
  453|      0|                       let date2 = resourceValue2.contentAccessDate
  454|      0|                    {
  455|      0|                        return date1.compare(date2) == .orderedAscending
  456|      0|                    }
  457|      0|                    
  458|      0|                    // Not valid date information. This should not happen. Just in case.
  459|      0|                    return true
  460|      0|                }
  461|      0|                
  462|      0|                for fileURL in sortedFiles {
  463|      0|                    
  464|      0|                    do {
  465|      0|                        try self.fileManager.removeItem(at: fileURL)
  466|      0|                    } catch { }
  467|      0|                        
  468|      0|                    URLsToDelete.append(fileURL)
  469|      0|                    
  470|      0|                    if let fileSize = cachedFiles[fileURL]?.totalFileAllocatedSize {
  471|      0|                        diskCacheSize -= UInt(fileSize)
  472|      0|                    }
  473|      0|                    
  474|      0|                    if diskCacheSize < targetSize {
  475|      0|                        break
  476|      0|                    }
  477|      0|                }
  478|      0|            }
  479|      0|                
  480|      0|            DispatchQueue.main.async {
  481|      0|                
  482|      0|                if URLsToDelete.count != 0 {
  483|      0|                    let cleanedHashes = URLsToDelete.map { $0.lastPathComponent }
  484|      0|                    NotificationCenter.default.post(name: .KingfisherDidCleanDiskCache, object: self, userInfo: [KingfisherDiskCacheCleanedHashKey: cleanedHashes])
  485|      0|                }
  486|      0|                
  487|      0|                handler?()
  488|      0|            }
  489|      0|        }
  490|      0|    }
  491|       |    
  492|      0|    fileprivate func travelCachedFiles(onlyForCacheSize: Bool) -> (urlsToDelete: [URL], diskCacheSize: UInt, cachedFiles: [URL: URLResourceValues]) {
  493|      0|        
  494|      0|        let diskCacheURL = URL(fileURLWithPath: diskCachePath)
  495|      0|        let resourceKeys: Set<URLResourceKey> = [.isDirectoryKey, .contentAccessDateKey, .totalFileAllocatedSizeKey]
  496|      0|        let expiredDate: Date? = (maxCachePeriodInSecond < 0) ? nil : Date(timeIntervalSinceNow: -maxCachePeriodInSecond)
  497|      0|        
  498|      0|        var cachedFiles = [URL: URLResourceValues]()
  499|      0|        var urlsToDelete = [URL]()
  500|      0|        var diskCacheSize: UInt = 0
  501|      0|
  502|      0|        for fileUrl in (try? fileManager.contentsOfDirectory(at: diskCacheURL, includingPropertiesForKeys: Array(resourceKeys), options: .skipsHiddenFiles)) ?? [] {
  503|      0|
  504|      0|            do {
  505|      0|                let resourceValues = try fileUrl.resourceValues(forKeys: resourceKeys)
  506|      0|                // If it is a Directory. Continue to next file URL.
  507|      0|                if resourceValues.isDirectory == true {
  508|      0|                    continue
  509|      0|                }
  510|      0|
  511|      0|                // If this file is expired, add it to URLsToDelete
  512|      0|                if !onlyForCacheSize,
  513|      0|                    let expiredDate = expiredDate,
  514|      0|                    let lastAccessData = resourceValues.contentAccessDate,
  515|      0|                    (lastAccessData as NSDate).laterDate(expiredDate) == expiredDate
  516|      0|                {
  517|      0|                    urlsToDelete.append(fileUrl)
  518|      0|                    continue
  519|      0|                }
  520|      0|
  521|      0|                if let fileSize = resourceValues.totalFileAllocatedSize {
  522|      0|                    diskCacheSize += UInt(fileSize)
  523|      0|                    if !onlyForCacheSize {
  524|      0|                        cachedFiles[fileUrl] = resourceValues
  525|      0|                    }
  526|      0|                }
  527|      0|            } catch _ { }
  528|      0|        }
  529|      0|
  530|      0|        return (urlsToDelete, diskCacheSize, cachedFiles)
  531|      0|    }
  532|       |
  533|       |#if !os(macOS) && !os(watchOS)
  534|       |    /**
  535|       |    Clean expired disk cache when app in background. This is an async operation.
  536|       |    In most cases, you should not call this method explicitly. 
  537|       |    It will be called automatically when `UIApplicationDidEnterBackgroundNotification` received.
  538|       |    */
  539|      0|    @objc public func backgroundCleanExpiredDiskCache() {
  540|      0|        // if 'sharedApplication()' is unavailable, then return
  541|      0|        guard let sharedApplication = Kingfisher<UIApplication>.shared else { return }
  542|      0|
  543|      0|        func endBackgroundTask(_ task: inout UIBackgroundTaskIdentifier) {
  544|      0|            sharedApplication.endBackgroundTask(task)
  545|      0|            task = UIBackgroundTaskInvalid
  546|      0|        }
  547|      0|        
  548|      0|        var backgroundTask: UIBackgroundTaskIdentifier!
  549|      0|        backgroundTask = sharedApplication.beginBackgroundTask {
  550|      0|            endBackgroundTask(&backgroundTask!)
  551|      0|        }
  552|      0|        
  553|      0|        cleanExpiredDiskCache {
  554|      0|            endBackgroundTask(&backgroundTask!)
  555|      0|        }
  556|      0|    }
  557|       |#endif
  558|       |
  559|       |
  560|       |    // MARK: - Check cache status
  561|       |    
  562|       |    /// Cache type for checking whether an image is cached for a key in current cache.
  563|       |    ///
  564|       |    /// - Parameters:
  565|       |    ///   - key: Key for the image.
  566|       |    ///   - identifier: Processor identifier which used for this image. Default is empty string.
  567|       |    /// - Returns: A `CacheType` instance which indicates the cache status. `.none` means the image is not in cache yet.
  568|      0|    open func imageCachedType(forKey key: String, processorIdentifier identifier: String = "") -> CacheType {
  569|      0|        let computedKey = key.computedKey(with: identifier)
  570|      0|        
  571|      0|        if memoryCache.object(forKey: computedKey as NSString) != nil {
  572|      0|            return .memory
  573|      0|        }
  574|      0|        
  575|      0|        let filePath = cachePath(forComputedKey: computedKey)
  576|      0|        
  577|      0|        var diskCached = false
  578|      0|        ioQueue.sync {
  579|      0|            diskCached = fileManager.fileExists(atPath: filePath)
  580|      0|        }
  581|      0|        
  582|      0|        if diskCached {
  583|      0|            return .disk
  584|      0|        }
  585|      0|        
  586|      0|        return .none
  587|      0|    }
  588|       |    
  589|       |    /**
  590|       |    Get the hash for the key. This could be used for matching files.
  591|       |    
  592|       |    - parameter key:        The key which is used for caching.
  593|       |    - parameter identifier: The identifier of processor used. If you are using a processor for the image, pass the identifier of processor to it.
  594|       |    
  595|       |     - returns: Corresponding hash.
  596|       |    */
  597|      0|    open func hash(forKey key: String, processorIdentifier identifier: String = "") -> String {
  598|      0|        let computedKey = key.computedKey(with: identifier)
  599|      0|        return cacheFileName(forComputedKey: computedKey)
  600|      0|    }
  601|       |    
  602|       |    /**
  603|       |    Calculate the disk size taken by cache. 
  604|       |    It is the total allocated size of the cached files in bytes.
  605|       |    
  606|       |    - parameter completionHandler: Called with the calculated size when finishes.
  607|       |    */
  608|      0|    open func calculateDiskCacheSize(completion handler: @escaping ((_ size: UInt) -> Void)) {
  609|      0|        ioQueue.async {
  610|      0|            let (_, diskCacheSize, _) = self.travelCachedFiles(onlyForCacheSize: true)
  611|      0|            DispatchQueue.main.async {
  612|      0|                handler(diskCacheSize)
  613|      0|            }
  614|      0|        }
  615|      0|    }
  616|       |    
  617|       |    /**
  618|       |    Get the cache path for the key.
  619|       |    It is useful for projects with UIWebView or anyone that needs access to the local file path.
  620|       |    
  621|       |    i.e. Replace the `<img src='path_for_key'>` tag in your HTML.
  622|       |     
  623|       |    - Note: This method does not guarantee there is an image already cached in the path. It just returns the path
  624|       |      that the image should be.
  625|       |      You could use `isImageCached(forKey:)` method to check whether the image is cached under that key.
  626|       |    */
  627|      0|    open func cachePath(forKey key: String, processorIdentifier identifier: String = "") -> String {
  628|      0|        let computedKey = key.computedKey(with: identifier)
  629|      0|        return cachePath(forComputedKey: computedKey)
  630|      0|    }
  631|       |
  632|      0|    open func cachePath(forComputedKey key: String) -> String {
  633|      0|        let fileName = cacheFileName(forComputedKey: key)
  634|      0|        return (diskCachePath as NSString).appendingPathComponent(fileName)
  635|      0|    }
  636|       |}
  637|       |
  638|       |// MARK: - Internal Helper
  639|       |extension ImageCache {
  640|       |  
  641|       |    func diskImage(forComputedKey key: String, serializer: CacheSerializer, options: KingfisherOptionsInfo) -> Image? {
  642|       |        if let data = diskImageData(forComputedKey: key) {
  643|       |            return serializer.image(with: data, options: options)
  644|       |        } else {
  645|       |            return nil
  646|       |        }
  647|       |    }
  648|       |    
  649|       |    func diskImageData(forComputedKey key: String) -> Data? {
  650|       |        let filePath = cachePath(forComputedKey: key)
  651|       |        return (try? Data(contentsOf: URL(fileURLWithPath: filePath)))
  652|       |    }
  653|       |    
  654|       |    func cacheFileName(forComputedKey key: String) -> String {
  655|       |        if let ext = self.pathExtension {
  656|       |          return (key.kf.md5 as NSString).appendingPathExtension(ext)!
  657|       |        }
  658|       |        return key.kf.md5
  659|       |    }
  660|       |}
  661|       |
  662|       |// MARK: - Deprecated
  663|       |extension ImageCache {
  664|       |    /**
  665|       |     *  Cache result for checking whether an image is cached for a key.
  666|       |     */
  667|       |    @available(*, deprecated,
  668|       |    message: "CacheCheckResult is deprecated. Use imageCachedType(forKey:processorIdentifier:) API instead.")
  669|       |    public struct CacheCheckResult {
  670|       |        public let cached: Bool
  671|       |        public let cacheType: CacheType?
  672|       |    }
  673|       |    
  674|       |    /**
  675|       |     Check whether an image is cached for a key.
  676|       |     
  677|       |     - parameter key: Key for the image.
  678|       |     
  679|       |     - returns: The check result.
  680|       |     */
  681|       |    @available(*, deprecated,
  682|       |    message: "Use imageCachedType(forKey:processorIdentifier:) instead. CacheCheckResult.none indicates not being cached.",
  683|       |    renamed: "imageCachedType(forKey:processorIdentifier:)")
  684|      0|    open func isImageCached(forKey key: String, processorIdentifier identifier: String = "") -> CacheCheckResult {
  685|      0|        let result = imageCachedType(forKey: key, processorIdentifier: identifier)
  686|      0|        switch result {
  687|      0|        case .memory, .disk:
  688|      0|            return CacheCheckResult(cached: true, cacheType: result)
  689|      0|        case .none:
  690|      0|            return CacheCheckResult(cached: false, cacheType: nil)
  691|      0|        }
  692|      0|    }
  693|       |}
  694|       |
  695|       |extension Kingfisher where Base: Image {
  696|       |    var imageCost: Int {
  697|       |        return images == nil ?
  698|       |            Int(size.height * size.width * scale * scale) :
  699|       |            Int(size.height * size.width * scale * scale) * images!.count
  700|       |    }
  701|       |}
  702|       |
  703|       |extension Dictionary {
  704|       |    func keysSortedByValue(_ isOrderedBefore: (Value, Value) -> Bool) -> [Key] {
  705|      0|        return Array(self).sorted{ isOrderedBefore($0.1, $1.1) }.map{ $0.0 }
  706|       |    }
  707|       |}
  708|       |
  709|       |#if !os(macOS) && !os(watchOS)
  710|       |// MARK: - For App Extensions
  711|       |extension UIApplication: KingfisherCompatible { }
  712|       |extension Kingfisher where Base: UIApplication {
  713|       |    public static var shared: UIApplication? {
  714|       |        let selector = NSSelectorFromString("sharedApplication")
  715|       |        guard Base.responds(to: selector) else { return nil }
  716|       |        return Base.perform(selector).takeUnretainedValue() as? UIApplication
  717|       |    }
  718|       |}
  719|       |#endif
  720|       |
  721|       |extension String {
  722|       |    func computedKey(with identifier: String) -> String {
  723|       |        if identifier.isEmpty {
  724|       |            return self
  725|       |        } else {
  726|       |            return appending("@\(identifier)")
  727|       |        }
  728|       |    }
  729|       |}

/Users/raduj/Developer/Appub/Pods/Kingfisher/Sources/ImageDownloader.swift:
    1|       |//
    2|       |//  ImageDownloader.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 15/4/6.
    6|       |//
    7|       |//  Copyright (c) 2018 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |#if os(macOS)
   28|       |import AppKit
   29|       |#else
   30|       |import UIKit
   31|       |#endif
   32|       |
   33|       |/// Progress update block of downloader.
   34|       |public typealias ImageDownloaderProgressBlock = DownloadProgressBlock
   35|       |
   36|       |/// Completion block of downloader.
   37|       |public typealias ImageDownloaderCompletionHandler = ((_ image: Image?, _ error: NSError?, _ url: URL?, _ originalData: Data?) -> Void)
   38|       |
   39|       |/// Download task.
   40|       |public struct RetrieveImageDownloadTask {
   41|       |    let internalTask: URLSessionDataTask
   42|       |    
   43|       |    /// Downloader by which this task is initialized.
   44|       |    public private(set) weak var ownerDownloader: ImageDownloader?
   45|       |
   46|       |    
   47|       |    /// Cancel this download task. It will trigger the completion handler with an NSURLErrorCancelled error.
   48|       |    /// If you want to cancel all downloading tasks, call `cancelAll()` of `ImageDownloader` instance.
   49|      0|    public func cancel() {
   50|      0|        ownerDownloader?.cancel(self)
   51|      0|    }
   52|       |    
   53|       |    /// The original request URL of this download task.
   54|      0|    public var url: URL? {
   55|      0|        return internalTask.originalRequest?.url
   56|      0|    }
   57|       |    
   58|       |    /// The relative priority of this download task. 
   59|       |    /// It represents the `priority` property of the internal `NSURLSessionTask` of this download task.
   60|       |    /// The value for it is between 0.0~1.0. Default priority is value of 0.5.
   61|       |    /// See documentation on `priority` of `NSURLSessionTask` for more about it.
   62|       |    public var priority: Float {
   63|      0|        get {
   64|      0|            return internalTask.priority
   65|      0|        }
   66|      0|        set {
   67|      0|            internalTask.priority = newValue
   68|      0|        }
   69|       |    }
   70|       |}
   71|       |
   72|       |///The code of errors which `ImageDownloader` might encountered.
   73|       |public enum KingfisherError: Int {
   74|       |    
   75|       |    /// badData: The downloaded data is not an image or the data is corrupted.
   76|       |    case badData = 10000
   77|       |    
   78|       |    /// notModified: The remote server responded a 304 code. No image data downloaded.
   79|       |    case notModified = 10001
   80|       |    
   81|       |    /// The HTTP status code in response is not valid. If an invalid
   82|       |    /// code error received, you could check the value under `KingfisherErrorStatusCodeKey` 
   83|       |    /// in `userInfo` to see the code.
   84|       |    case invalidStatusCode = 10002
   85|       |    
   86|       |    /// notCached: The image requested is not in cache but .onlyFromCache is activated.
   87|       |    case notCached = 10003
   88|       |    
   89|       |    /// The URL is invalid.
   90|       |    case invalidURL = 20000
   91|       |    
   92|       |    /// The downloading task is cancelled before started.
   93|       |    case downloadCancelledBeforeStarting = 30000
   94|       |}
   95|       |
   96|       |/// Key will be used in the `userInfo` of `.invalidStatusCode`
   97|       |public let KingfisherErrorStatusCodeKey = "statusCode"
   98|       |
   99|       |/// Protocol of `ImageDownloader`.
  100|       |public protocol ImageDownloaderDelegate: class {
  101|       |    /**
  102|       |     Called when the `ImageDownloader` object will start downloading an image from specified URL.
  103|       |     
  104|       |     - parameter downloader: The `ImageDownloader` object finishes the downloading.
  105|       |     - parameter url:        URL of the original request URL.
  106|       |     - parameter response:   The request object for the download process.
  107|       |     */
  108|       |    func imageDownloader(_ downloader: ImageDownloader, willDownloadImageForURL url: URL, with request: URLRequest?)
  109|       |    
  110|       |    /**
  111|       |     Called when the `ImageDownloader` completes a downloading request with success or failure.
  112|       |     
  113|       |     - parameter downloader: The `ImageDownloader` object finishes the downloading.
  114|       |     - parameter url:        URL of the original request URL.
  115|       |     - parameter response:   The response object of the downloading process.
  116|       |     - parameter error:      The error in case of failure.
  117|       |     */
  118|       |    func imageDownloader(_ downloader: ImageDownloader, didFinishDownloadingImageForURL url: URL, with response: URLResponse?, error: Error?)
  119|       |    
  120|       |    /**
  121|       |    Called when the `ImageDownloader` object successfully downloaded an image from specified URL.
  122|       |    
  123|       |    - parameter downloader: The `ImageDownloader` object finishes the downloading.
  124|       |    - parameter image:      Downloaded image.
  125|       |    - parameter url:        URL of the original request URL.
  126|       |    - parameter response:   The response object of the downloading process.
  127|       |    */
  128|       |    func imageDownloader(_ downloader: ImageDownloader, didDownload image: Image, for url: URL, with response: URLResponse?)
  129|       |    
  130|       |    /**
  131|       |    Check if a received HTTP status code is valid or not. 
  132|       |    By default, a status code between 200 to 400 (excluded) is considered as valid.
  133|       |    If an invalid code is received, the downloader will raise an .invalidStatusCode error.
  134|       |    It has a `userInfo` which includes this statusCode and localizedString error message.
  135|       |     
  136|       |    - parameter code: The received HTTP status code.
  137|       |    - parameter downloader: The `ImageDownloader` object asking for validate status code.
  138|       |     
  139|       |    - returns: Whether this HTTP status code is valid or not.
  140|       |     
  141|       |    - Note: If the default 200 to 400 valid code does not suit your need, 
  142|       |            you can implement this method to change that behavior.
  143|       |    */
  144|       |    func isValidStatusCode(_ code: Int, for downloader: ImageDownloader) -> Bool
  145|       |    
  146|       |    /**
  147|       |     Called when the `ImageDownloader` object successfully downloaded image data from specified URL.
  148|       |     
  149|       |     - parameter downloader: The `ImageDownloader` object finishes data downloading.
  150|       |     - parameter data:       Downloaded data.
  151|       |     - parameter url:        URL of the original request URL.
  152|       |     
  153|       |     - returns: The data from which Kingfisher should use to create an image.
  154|       |     
  155|       |     - Note: This callback can be used to preprocess raw image data
  156|       |             before creation of UIImage instance (i.e. decrypting or verification).
  157|       |     */
  158|       |    func imageDownloader(_ downloader: ImageDownloader, didDownload data: Data, for url: URL) -> Data?
  159|       |}
  160|       |
  161|       |extension ImageDownloaderDelegate {
  162|       |    
  163|      0|    public func imageDownloader(_ downloader: ImageDownloader, willDownloadImageForURL url: URL, with request: URLRequest?) {}
  164|       |    
  165|      0|    public func imageDownloader(_ downloader: ImageDownloader, didFinishDownloadingImageForURL url: URL, with response: URLResponse?, error: Error?) {}
  166|       |    
  167|      0|    public func imageDownloader(_ downloader: ImageDownloader, didDownload image: Image, for url: URL, with response: URLResponse?) {}
  168|       |    
  169|      0|    public func isValidStatusCode(_ code: Int, for downloader: ImageDownloader) -> Bool {
  170|      0|        return (200..<400).contains(code)
  171|      0|    }
  172|      0|    public func imageDownloader(_ downloader: ImageDownloader, didDownload data: Data, for url: URL) -> Data? {
  173|      0|        return data
  174|      0|    }
  175|       |}
  176|       |
  177|       |/// Protocol indicates that an authentication challenge could be handled.
  178|       |public protocol AuthenticationChallengeResponsable: class {
  179|       |    /**
  180|       |     Called when an session level authentication challenge is received.
  181|       |     This method provide a chance to handle and response to the authentication challenge before downloading could start.
  182|       |     
  183|       |     - parameter downloader:        The downloader which receives this challenge.
  184|       |     - parameter challenge:         An object that contains the request for authentication.
  185|       |     - parameter completionHandler: A handler that your delegate method must call.
  186|       |     
  187|       |     - Note: This method is a forward from `URLSessionDelegate.urlSession(:didReceiveChallenge:completionHandler:)`. Please refer to the document of it in `URLSessionDelegate`.
  188|       |     */
  189|       |    func downloader(_ downloader: ImageDownloader, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void)
  190|       |
  191|       |    /**
  192|       |     Called when an session level authentication challenge is received.
  193|       |     This method provide a chance to handle and response to the authentication challenge before downloading could start.
  194|       |     
  195|       |     - parameter downloader:        The downloader which receives this challenge.
  196|       |     - parameter task:              The task whose request requires authentication.
  197|       |     - parameter challenge:         An object that contains the request for authentication.
  198|       |     - parameter completionHandler: A handler that your delegate method must call.
  199|       |     
  200|       |     - Note: This method is a forward from `URLSessionTaskDelegate.urlSession(:task:didReceiveChallenge:completionHandler:)`. Please refer to the document of it in `URLSessionTaskDelegate`.
  201|       |     */
  202|       |    func downloader(_ downloader: ImageDownloader, task: URLSessionTask, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void)
  203|       |}
  204|       |
  205|       |extension AuthenticationChallengeResponsable {
  206|       |    
  207|      0|    func downloader(_ downloader: ImageDownloader, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
  208|      0|    
  209|      0|        if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
  210|      0|            if let trustedHosts = downloader.trustedHosts, trustedHosts.contains(challenge.protectionSpace.host) {
  211|      0|                let credential = URLCredential(trust: challenge.protectionSpace.serverTrust!)
  212|      0|                completionHandler(.useCredential, credential)
  213|      0|                return
  214|      0|            }
  215|      0|        }
  216|      0|        
  217|      0|        completionHandler(.performDefaultHandling, nil)
  218|      0|    }
  219|       |    
  220|      0|    func downloader(_ downloader: ImageDownloader, task: URLSessionTask, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
  221|      0|        
  222|      0|        completionHandler(.performDefaultHandling, nil)
  223|      0|    }
  224|       |
  225|       |}
  226|       |
  227|       |/// `ImageDownloader` represents a downloading manager for requesting the image with a URL from server.
  228|       |open class ImageDownloader {
  229|       |    
  230|       |    class ImageFetchLoad {
  231|       |        var contents = [(callback: CallbackPair, options: KingfisherOptionsInfo)]()
  232|       |        var responseData = NSMutableData()
  233|       |
  234|       |        var downloadTaskCount = 0
  235|       |        var downloadTask: RetrieveImageDownloadTask?
  236|       |        var cancelSemaphore: DispatchSemaphore?
  237|       |    }
  238|       |    
  239|       |    // MARK: - Public property
  240|       |    /// The duration before the download is timeout. Default is 15 seconds.
  241|       |    open var downloadTimeout: TimeInterval = 15.0
  242|       |    
  243|       |    /// A set of trusted hosts when receiving server trust challenges. A challenge with host name contained in this set will be ignored. 
  244|       |    /// You can use this set to specify the self-signed site. It only will be used if you don't specify the `authenticationChallengeResponder`. 
  245|       |    /// If `authenticationChallengeResponder` is set, this property will be ignored and the implementation of `authenticationChallengeResponder` will be used instead.
  246|       |    open var trustedHosts: Set<String>?
  247|       |    
  248|       |    /// Use this to set supply a configuration for the downloader. By default, NSURLSessionConfiguration.ephemeralSessionConfiguration() will be used. 
  249|       |    /// You could change the configuration before a downloading task starts. A configuration without persistent storage for caches is requested for downloader working correctly.
  250|       |    open var sessionConfiguration = URLSessionConfiguration.ephemeral {
  251|      0|        didSet {
  252|      0|            session?.invalidateAndCancel()
  253|      0|            session = URLSession(configuration: sessionConfiguration, delegate: sessionHandler, delegateQueue: nil)
  254|      0|        }
  255|       |    }
  256|       |    
  257|       |    /// Whether the download requests should use pipline or not. Default is false.
  258|       |    open var requestsUsePipelining = false
  259|       |    
  260|       |    fileprivate let sessionHandler: ImageDownloaderSessionHandler
  261|       |    fileprivate var session: URLSession?
  262|       |    
  263|       |    /// Delegate of this `ImageDownloader` object. See `ImageDownloaderDelegate` protocol for more.
  264|       |    open weak var delegate: ImageDownloaderDelegate?
  265|       |    
  266|       |    /// A responder for authentication challenge. 
  267|       |    /// Downloader will forward the received authentication challenge for the downloading session to this responder.
  268|       |    open weak var authenticationChallengeResponder: AuthenticationChallengeResponsable?
  269|       |    
  270|       |    // MARK: - Internal property
  271|       |    let barrierQueue: DispatchQueue
  272|       |    let processQueue: DispatchQueue
  273|       |    let cancelQueue: DispatchQueue
  274|       |    
  275|       |    typealias CallbackPair = (progressBlock: ImageDownloaderProgressBlock?, completionHandler: ImageDownloaderCompletionHandler?)
  276|       |    
  277|       |    var fetchLoads = [URL: ImageFetchLoad]()
  278|       |    
  279|       |    // MARK: - Public method
  280|       |    /// The default downloader.
  281|       |    public static let `default` = ImageDownloader(name: "default")
  282|       |    
  283|       |    /**
  284|       |    Init a downloader with name.
  285|       |    
  286|       |    - parameter name: The name for the downloader. It should not be empty.
  287|       |    
  288|       |    - returns: The downloader object.
  289|       |    */
  290|      0|    public init(name: String) {
  291|      0|        if name.isEmpty {
  292|      0|            fatalError("[Kingfisher] You should specify a name for the downloader. A downloader with empty name is not permitted.")
  293|      0|        }
  294|      0|        
  295|      0|        barrierQueue = DispatchQueue(label: "com.onevcat.Kingfisher.ImageDownloader.Barrier.\(name)", attributes: .concurrent)
  296|      0|        processQueue = DispatchQueue(label: "com.onevcat.Kingfisher.ImageDownloader.Process.\(name)", attributes: .concurrent)
  297|      0|        cancelQueue = DispatchQueue(label: "com.onevcat.Kingfisher.ImageDownloader.Cancel.\(name)")
  298|      0|        
  299|      0|        sessionHandler = ImageDownloaderSessionHandler()
  300|      0|
  301|      0|        // Provide a default implement for challenge responder.
  302|      0|        authenticationChallengeResponder = sessionHandler
  303|      0|        session = URLSession(configuration: sessionConfiguration, delegate: sessionHandler, delegateQueue: .main)
  304|      0|    }
  305|       |    
  306|      0|    deinit {
  307|      0|        session?.invalidateAndCancel()
  308|      0|    }
  309|       |    
  310|      0|    func fetchLoad(for url: URL) -> ImageFetchLoad? {
  311|      0|        var fetchLoad: ImageFetchLoad?
  312|      0|        barrierQueue.sync(flags: .barrier) { fetchLoad = fetchLoads[url] }
  313|      0|        return fetchLoad
  314|      0|    }
  315|       |    
  316|       |    /**
  317|       |     Download an image with a URL and option.
  318|       |     
  319|       |     - parameter url:               Target URL.
  320|       |     - parameter retrieveImageTask: The task to cooperate with cache. Pass `nil` if you are not trying to use downloader and cache.
  321|       |     - parameter options:           The options could control download behavior. See `KingfisherOptionsInfo`.
  322|       |     - parameter progressBlock:     Called when the download progress updated.
  323|       |     - parameter completionHandler: Called when the download progress finishes.
  324|       |     
  325|       |     - returns: A downloading task. You could call `cancel` on it to stop the downloading process.
  326|       |     */
  327|       |    @discardableResult
  328|       |    open func downloadImage(with url: URL,
  329|       |                       retrieveImageTask: RetrieveImageTask? = nil,
  330|       |                       options: KingfisherOptionsInfo? = nil,
  331|       |                       progressBlock: ImageDownloaderProgressBlock? = nil,
  332|       |                       completionHandler: ImageDownloaderCompletionHandler? = nil) -> RetrieveImageDownloadTask?
  333|      0|    {
  334|      0|        if let retrieveImageTask = retrieveImageTask, retrieveImageTask.cancelledBeforeDownloadStarting {
  335|      0|            completionHandler?(nil, NSError(domain: KingfisherErrorDomain, code: KingfisherError.downloadCancelledBeforeStarting.rawValue, userInfo: nil), nil, nil)
  336|      0|            return nil
  337|      0|        }
  338|      0|        
  339|      0|        let timeout = self.downloadTimeout == 0.0 ? 15.0 : self.downloadTimeout
  340|      0|        
  341|      0|        // We need to set the URL as the load key. So before setup progress, we need to ask the `requestModifier` for a final URL.
  342|      0|        var request = URLRequest(url: url, cachePolicy: .reloadIgnoringLocalCacheData, timeoutInterval: timeout)
  343|      0|        request.httpShouldUsePipelining = requestsUsePipelining
  344|      0|
  345|      0|        if let modifier = options?.modifier {
  346|      0|            guard let r = modifier.modified(for: request) else {
  347|      0|                completionHandler?(nil, NSError(domain: KingfisherErrorDomain, code: KingfisherError.downloadCancelledBeforeStarting.rawValue, userInfo: nil), nil, nil)
  348|      0|                return nil
  349|      0|            }
  350|      0|            request = r
  351|      0|        }
  352|      0|        
  353|      0|        // There is a possibility that request modifier changed the url to `nil` or empty.
  354|      0|        guard let url = request.url, !url.absoluteString.isEmpty else {
  355|      0|            completionHandler?(nil, NSError(domain: KingfisherErrorDomain, code: KingfisherError.invalidURL.rawValue, userInfo: nil), nil, nil)
  356|      0|            return nil
  357|      0|        }
  358|      0|        
  359|      0|        var downloadTask: RetrieveImageDownloadTask?
  360|      0|        setup(progressBlock: progressBlock, with: completionHandler, for: url, options: options) {(session, fetchLoad) -> Void in
  361|      0|            if fetchLoad.downloadTask == nil {
  362|      0|                let dataTask = session.dataTask(with: request)
  363|      0|                
  364|      0|                fetchLoad.downloadTask = RetrieveImageDownloadTask(internalTask: dataTask, ownerDownloader: self)
  365|      0|                
  366|      0|                dataTask.priority = options?.downloadPriority ?? URLSessionTask.defaultPriority
  367|      0|                self.delegate?.imageDownloader(self, willDownloadImageForURL: url, with: request)
  368|      0|                dataTask.resume()
  369|      0|                
  370|      0|                // Hold self while the task is executing.
  371|      0|                self.sessionHandler.downloadHolder = self
  372|      0|            }
  373|      0|            
  374|      0|            fetchLoad.downloadTaskCount += 1
  375|      0|            downloadTask = fetchLoad.downloadTask
  376|      0|            
  377|      0|            retrieveImageTask?.downloadTask = downloadTask
  378|      0|        }
  379|      0|        return downloadTask
  380|      0|    }
  381|       |    
  382|       |}
  383|       |
  384|       |// MARK: - Download method
  385|       |extension ImageDownloader {
  386|       |    
  387|       |    // A single key may have multiple callbacks. Only download once.
  388|       |    func setup(progressBlock: ImageDownloaderProgressBlock?, with completionHandler: ImageDownloaderCompletionHandler?, for url: URL, options: KingfisherOptionsInfo?, started: @escaping ((URLSession, ImageFetchLoad) -> Void)) {
  389|       |
  390|      0|        func prepareFetchLoad() {
  391|      0|            barrierQueue.sync(flags: .barrier) {
  392|      0|                let loadObjectForURL = fetchLoads[url] ?? ImageFetchLoad()
  393|      0|                let callbackPair = (progressBlock: progressBlock, completionHandler: completionHandler)
  394|      0|                
  395|      0|                loadObjectForURL.contents.append((callbackPair, options ?? KingfisherEmptyOptionsInfo))
  396|      0|                
  397|      0|                fetchLoads[url] = loadObjectForURL
  398|      0|                
  399|      0|                if let session = session {
  400|      0|                    started(session, loadObjectForURL)
  401|      0|                }
  402|      0|            }
  403|      0|        }
  404|       |        
  405|       |        if let fetchLoad = fetchLoad(for: url), fetchLoad.downloadTaskCount == 0 {
  406|       |            if fetchLoad.cancelSemaphore == nil {
  407|       |                fetchLoad.cancelSemaphore = DispatchSemaphore(value: 0)
  408|       |            }
  409|      0|            cancelQueue.async {
  410|      0|                _ = fetchLoad.cancelSemaphore?.wait(timeout: .distantFuture)
  411|      0|                fetchLoad.cancelSemaphore = nil
  412|      0|                prepareFetchLoad()
  413|      0|            }
  414|       |        } else {
  415|       |            prepareFetchLoad()
  416|       |        }
  417|       |    }
  418|       |    
  419|      0|    private func cancelTaskImpl(_ task: RetrieveImageDownloadTask, fetchLoad: ImageFetchLoad? = nil, ignoreTaskCount: Bool = false) {
  420|      0|        
  421|      0|        func getFetchLoad(from task: RetrieveImageDownloadTask) -> ImageFetchLoad? {
  422|      0|            guard let URL = task.internalTask.originalRequest?.url,
  423|      0|                  let imageFetchLoad = self.fetchLoads[URL] else
  424|      0|            {
  425|      0|                return nil
  426|      0|            }
  427|      0|            return imageFetchLoad
  428|      0|        }
  429|      0|        
  430|      0|        guard let imageFetchLoad = fetchLoad ?? getFetchLoad(from: task) else {
  431|      0|            return
  432|      0|        }
  433|      0|
  434|      0|        imageFetchLoad.downloadTaskCount -= 1
  435|      0|        if ignoreTaskCount || imageFetchLoad.downloadTaskCount == 0 {
  436|      0|            task.internalTask.cancel()
  437|      0|        }
  438|      0|    }
  439|       |    
  440|       |    func cancel(_ task: RetrieveImageDownloadTask) {
  441|      0|        barrierQueue.sync(flags: .barrier) { cancelTaskImpl(task) }
  442|       |    }
  443|       |    
  444|       |    /// Cancel all downloading tasks. It will trigger the completion handlers for all not-yet-finished
  445|       |    /// downloading tasks with an NSURLErrorCancelled error.
  446|       |    ///
  447|       |    /// If you need to only cancel a certain task, call `cancel()` on the `RetrieveImageDownloadTask`
  448|       |    /// returned by the downloading methods.
  449|      0|    public func cancelAll() {
  450|      0|        barrierQueue.sync(flags: .barrier) {
  451|      0|            fetchLoads.forEach { v in
  452|      0|                let fetchLoad = v.value
  453|      0|                guard let task = fetchLoad.downloadTask else { return }
  454|      0|                cancelTaskImpl(task, fetchLoad: fetchLoad, ignoreTaskCount: true)
  455|      0|            }
  456|      0|        }
  457|      0|    }
  458|       |}
  459|       |
  460|       |// MARK: - NSURLSessionDataDelegate
  461|       |
  462|       |/// Delegate class for `NSURLSessionTaskDelegate`.
  463|       |/// The session object will hold its delegate until it gets invalidated.
  464|       |/// If we use `ImageDownloader` as the session delegate, it will not be released.
  465|       |/// So we need an additional handler to break the retain cycle.
  466|       |// See https://github.com/onevcat/Kingfisher/issues/235
  467|       |final class ImageDownloaderSessionHandler: NSObject, URLSessionDataDelegate, AuthenticationChallengeResponsable {
  468|       |    
  469|       |    // The holder will keep downloader not released while a data task is being executed.
  470|       |    // It will be set when the task started, and reset when the task finished.
  471|       |    var downloadHolder: ImageDownloader?
  472|       |    
  473|      0|    func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive response: URLResponse, completionHandler: @escaping (URLSession.ResponseDisposition) -> Void) {
  474|      0|        
  475|      0|        guard let downloader = downloadHolder else {
  476|      0|            completionHandler(.cancel)
  477|      0|            return
  478|      0|        }
  479|      0|        
  480|      0|        if let statusCode = (response as? HTTPURLResponse)?.statusCode,
  481|      0|           let url = dataTask.originalRequest?.url,
  482|      0|            !(downloader.delegate ?? downloader).isValidStatusCode(statusCode, for: downloader)
  483|      0|        {
  484|      0|            let error = NSError(domain: KingfisherErrorDomain,
  485|      0|                                code: KingfisherError.invalidStatusCode.rawValue,
  486|      0|                                userInfo: [KingfisherErrorStatusCodeKey: statusCode, NSLocalizedDescriptionKey: HTTPURLResponse.localizedString(forStatusCode: statusCode)])
  487|      0|            
  488|      0|            // Needs to be called before callCompletionHandlerFailure() because it removes downloadHolder
  489|      0|            if let downloader = downloadHolder {
  490|      0|                downloader.delegate?.imageDownloader(downloader, didFinishDownloadingImageForURL: url, with: response, error: error)
  491|      0|            }
  492|      0|            
  493|      0|            callCompletionHandlerFailure(error: error, url: url)
  494|      0|        }
  495|      0|        
  496|      0|        completionHandler(.allow)
  497|      0|    }
  498|       |    
  499|      0|    func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data) {
  500|      0|
  501|      0|        guard let downloader = downloadHolder else {
  502|      0|            return
  503|      0|        }
  504|      0|
  505|      0|        if let url = dataTask.originalRequest?.url, let fetchLoad = downloader.fetchLoad(for: url) {
  506|      0|            fetchLoad.responseData.append(data)
  507|      0|            
  508|      0|            if let expectedLength = dataTask.response?.expectedContentLength {
  509|      0|                for content in fetchLoad.contents {
  510|      0|                    DispatchQueue.main.async {
  511|      0|                        content.callback.progressBlock?(Int64(fetchLoad.responseData.length), expectedLength)
  512|      0|                    }
  513|      0|                }
  514|      0|            }
  515|      0|        }
  516|      0|    }
  517|       |    
  518|      0|    func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) {
  519|      0|        
  520|      0|        guard let url = task.originalRequest?.url else {
  521|      0|            return
  522|      0|        }
  523|      0|        
  524|      0|        if let downloader = downloadHolder {
  525|      0|            downloader.delegate?.imageDownloader(downloader, didFinishDownloadingImageForURL: url, with: task.response, error: error)
  526|      0|        }
  527|      0|        
  528|      0|        guard error == nil else {
  529|      0|            callCompletionHandlerFailure(error: error!, url: url)
  530|      0|            return
  531|      0|        }
  532|      0|        
  533|      0|        processImage(for: task, url: url)
  534|      0|    }
  535|       |    
  536|       |    /**
  537|       |    This method is exposed since the compiler requests. Do not call it.
  538|       |    */
  539|      0|    func urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
  540|      0|        guard let downloader = downloadHolder else {
  541|      0|            return
  542|      0|        }
  543|      0|        
  544|      0|        downloader.authenticationChallengeResponder?.downloader(downloader, didReceive: challenge, completionHandler: completionHandler)
  545|      0|    }
  546|       |    
  547|      0|    func urlSession(_ session: URLSession, task: URLSessionTask, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
  548|      0|        guard let downloader = downloadHolder else {
  549|      0|            return
  550|      0|        }
  551|      0|        
  552|      0|        downloader.authenticationChallengeResponder?.downloader(downloader, task: task, didReceive: challenge, completionHandler: completionHandler)
  553|      0|    }
  554|       |    
  555|      0|    private func cleanFetchLoad(for url: URL) {
  556|      0|        guard let downloader = downloadHolder else {
  557|      0|            return
  558|      0|        }
  559|      0|
  560|      0|        downloader.barrierQueue.sync(flags: .barrier) {
  561|      0|            downloader.fetchLoads.removeValue(forKey: url)
  562|      0|            if downloader.fetchLoads.isEmpty {
  563|      0|                downloadHolder = nil
  564|      0|            }
  565|      0|        }
  566|      0|    }
  567|       |    
  568|       |    private func callCompletionHandlerFailure(error: Error, url: URL) {
  569|       |        guard let downloader = downloadHolder, let fetchLoad = downloader.fetchLoad(for: url) else {
  570|       |            return
  571|       |        }
  572|       |        
  573|       |        // We need to clean the fetch load first, before actually calling completion handler.
  574|       |        cleanFetchLoad(for: url)
  575|       |        
  576|       |        var leftSignal: Int
  577|       |        repeat {
  578|       |            leftSignal = fetchLoad.cancelSemaphore?.signal() ?? 0
  579|       |        } while leftSignal != 0
  580|       |        
  581|       |        for content in fetchLoad.contents {
  582|       |            content.options.callbackDispatchQueue.safeAsync {
  583|       |                content.callback.completionHandler?(nil, error as NSError, url, nil)
  584|       |            }
  585|       |        }
  586|       |    }
  587|       |    
  588|       |    private func processImage(for task: URLSessionTask, url: URL) {
  589|       |
  590|       |        guard let downloader = downloadHolder else {
  591|       |            return
  592|       |        }
  593|       |        
  594|       |        // We are on main queue when receiving this.
  595|      0|        downloader.processQueue.async {
  596|      0|            
  597|      0|            guard let fetchLoad = downloader.fetchLoad(for: url) else {
  598|      0|                return
  599|      0|            }
  600|      0|            
  601|      0|            self.cleanFetchLoad(for: url)
  602|      0|            
  603|      0|            let data: Data?
  604|      0|            let fetchedData = fetchLoad.responseData as Data
  605|      0|            
  606|      0|            if let delegate = downloader.delegate {
  607|      0|                data = delegate.imageDownloader(downloader, didDownload: fetchedData, for: url)
  608|      0|            } else {
  609|      0|                data = fetchedData
  610|      0|            }
  611|      0|            
  612|      0|            // Cache the processed images. So we do not need to re-process the image if using the same processor.
  613|      0|            // Key is the identifier of processor.
  614|      0|            var imageCache: [String: Image] = [:]
  615|      0|            for content in fetchLoad.contents {
  616|      0|                
  617|      0|                let options = content.options
  618|      0|                let completionHandler = content.callback.completionHandler
  619|      0|                let callbackQueue = options.callbackDispatchQueue
  620|      0|                
  621|      0|                let processor = options.processor
  622|      0|                var image = imageCache[processor.identifier]
  623|      0|                if let data = data, image == nil {
  624|      0|                    image = processor.process(item: .data(data), options: options)
  625|      0|                    // Add the processed image to cache. 
  626|      0|                    // If `image` is nil, nothing will happen (since the key is not existing before).
  627|      0|                    imageCache[processor.identifier] = image
  628|      0|                }
  629|      0|                
  630|      0|                if let image = image {
  631|      0|
  632|      0|                    downloader.delegate?.imageDownloader(downloader, didDownload: image, for: url, with: task.response)
  633|      0|
  634|      0|                    let imageModifier = options.imageModifier
  635|      0|                    let finalImage = imageModifier.modify(image)
  636|      0|
  637|      0|                    if options.backgroundDecode {
  638|      0|                        let decodedImage = finalImage.kf.decoded
  639|      0|                        callbackQueue.safeAsync { completionHandler?(decodedImage, nil, url, data) }
  640|      0|                    } else {
  641|      0|                        callbackQueue.safeAsync { completionHandler?(finalImage, nil, url, data) }
  642|      0|                    }
  643|      0|                    
  644|      0|                } else {
  645|      0|                    if let res = task.response as? HTTPURLResponse , res.statusCode == 304 {
  646|      0|                        let notModified = NSError(domain: KingfisherErrorDomain, code: KingfisherError.notModified.rawValue, userInfo: nil)
  647|      0|                        completionHandler?(nil, notModified, url, nil)
  648|      0|                        continue
  649|      0|                    }
  650|      0|                    
  651|      0|                    let badData = NSError(domain: KingfisherErrorDomain, code: KingfisherError.badData.rawValue, userInfo: nil)
  652|      0|                    callbackQueue.safeAsync { completionHandler?(nil, badData, url, nil) }
  653|      0|                }
  654|      0|            }
  655|      0|        }
  656|       |    }
  657|       |}
  658|       |
  659|       |// Placeholder. For retrieving extension methods of ImageDownloaderDelegate
  660|       |extension ImageDownloader: ImageDownloaderDelegate {}
  661|       |

/Users/raduj/Developer/Appub/Pods/Kingfisher/Sources/ImageModifier.swift:
    1|       |//
    2|       |//  ImageModifier.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Ethan Gill on 2017/11/28.
    6|       |//
    7|       |//  Copyright (c) 2018 Ethan Gill <ethan.gill@me.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import Foundation
   28|       |
   29|       |/// An `ImageModifier` can be used to change properties on an Image in between
   30|       |/// cache serialization and use of the image.
   31|       |public protocol ImageModifier {
   32|       |    /// Modify an input `Image`.
   33|       |    ///
   34|       |    /// - parameter image:   Image which will be modified by `self`
   35|       |    ///
   36|       |    /// - returns: The modified image.
   37|       |    ///
   38|       |    /// - Note: The return value will be unmodified if modifying is not possible on
   39|       |    ///         the current platform.
   40|       |    /// - Note: Most modifiers support UIImage or NSImage, but not CGImage.
   41|       |    func modify(_ image: Image) -> Image
   42|       |}
   43|       |
   44|       |extension ImageModifier {
   45|      0|    func modify(_ image: Image?) -> Image? {
   46|      0|        guard let image = image else {
   47|      0|            return nil
   48|      0|        }
   49|      0|        return modify(image)
   50|      0|    }
   51|       |}
   52|       |
   53|       |typealias ModifierImp = ((Image) -> Image)
   54|       |
   55|       |fileprivate struct GeneralModifier: ImageModifier {
   56|       |    let identifier: String
   57|       |    let m: ModifierImp
   58|      0|    func modify(_ image: Image) -> Image {
   59|      0|        return m(image)
   60|      0|    }
   61|       |}
   62|       |
   63|       |/// The default modifier.
   64|       |/// Does nothing and returns the image it was given
   65|       |public struct DefaultImageModifier: ImageModifier {
   66|       |
   67|       |    /// A default `DefaultImageModifier` which can be used everywhere.
   68|       |    public static let `default` = DefaultImageModifier()
   69|       |
   70|       |    /// Initialize a `DefaultImageModifier`
   71|      0|    private init() {}
   72|       |
   73|       |    /// Modify an input `Image`.
   74|       |    ///
   75|       |    /// - parameter image:   Image which will be modified by `self`
   76|       |    ///
   77|       |    /// - returns: The modified image.
   78|       |    ///
   79|       |    /// - Note: See documentation of `ImageModifier` protocol for more.
   80|      0|    public func modify(_ image: Image) -> Image {
   81|      0|        return image
   82|      0|    }
   83|       |}
   84|       |
   85|       |/// A custom modifier.
   86|       |/// Can be initialized with a block to modify images in a custom way
   87|       |public struct AnyImageModifier: ImageModifier {
   88|       |
   89|       |    /// A block which modifies images, or returns the original image
   90|       |    /// if modification cannot be performed.
   91|       |    let block: (Image) -> Image
   92|       |
   93|       |    /// Initialize an `AnyImageModifier`
   94|      0|    public init(modify: @escaping (Image) -> Image) {
   95|      0|        block = modify
   96|      0|    }
   97|       |
   98|       |    /// Modifies an input `Image` using this `AnyImageModifier`'s `block`.
   99|       |    ///
  100|       |    /// - parameter image:   Image which will be modified by `self`
  101|       |    ///
  102|       |    /// - returns: The modified image.
  103|       |    ///
  104|       |    /// - Note: See documentation of `ImageModifier` protocol for more.
  105|      0|    public func modify(_ image: Image) -> Image {
  106|      0|        return block(image)
  107|      0|    }
  108|       |}
  109|       |
  110|       |#if os(iOS) || os(tvOS) || os(watchOS)
  111|       |import UIKit
  112|       |
  113|       |/// Modifier for setting the rendering mode of images.
  114|       |/// Only UI-based images are supported; if a non-UI image is passed in, the
  115|       |/// modifier will do nothing.
  116|       |public struct RenderingModeImageModifier: ImageModifier {
  117|       |
  118|       |    /// The rendering mode to apply to the image.
  119|       |    public let renderingMode: UIImageRenderingMode
  120|       |
  121|       |    /// Initialize a `RenderingModeImageModifier`
  122|       |    ///
  123|       |    /// - parameter renderingMode: The rendering mode to apply to the image.
  124|       |    ///                            Default is .automatic
  125|      0|    public init(renderingMode: UIImageRenderingMode = .automatic) {
  126|      0|        self.renderingMode = renderingMode
  127|      0|    }
  128|       |
  129|       |    /// Modify an input `Image`.
  130|       |    ///
  131|       |    /// - parameter image:   Image which will be modified by `self`
  132|       |    ///
  133|       |    /// - returns: The modified image.
  134|       |    ///
  135|       |    /// - Note: See documentation of `ImageModifier` protocol for more.
  136|      0|    public func modify(_ image: Image) -> Image {
  137|      0|        return image.withRenderingMode(renderingMode)
  138|      0|    }
  139|       |}
  140|       |
  141|       |/// Modifier for setting the `flipsForRightToLeftLayoutDirection` property of images.
  142|       |/// Only UI-based images are supported; if a non-UI image is passed in, the
  143|       |/// modifier will do nothing.
  144|       |public struct FlipsForRightToLeftLayoutDirectionImageModifier: ImageModifier {
  145|       |    /// Initialize a `FlipsForRightToLeftLayoutDirectionImageModifier`
  146|       |    ///
  147|       |    /// - Note: On versions of iOS lower than 9.0, the image will be returned
  148|       |    ///         unmodified.
  149|      0|    public init() {}
  150|       |
  151|       |    /// Modify an input `Image`.
  152|       |    ///
  153|       |    /// - parameter image:   Image which will be modified by `self`
  154|       |    ///
  155|       |    /// - returns: The modified image.
  156|       |    ///
  157|       |    /// - Note: See documentation of `ImageModifier` protocol for more.
  158|      0|    public func modify(_ image: Image) -> Image {
  159|      0|        if #available(iOS 9.0, *) {
  160|      0|            return image.imageFlippedForRightToLeftLayoutDirection()
  161|      0|        } else {
  162|      0|            return image
  163|      0|        }
  164|      0|    }
  165|       |}
  166|       |
  167|       |/// Modifier for setting the `alignmentRectInsets` property of images.
  168|       |/// Only UI-based images are supported; if a non-UI image is passed in, the
  169|       |/// modifier will do nothing.
  170|       |public struct AlignmentRectInsetsImageModifier: ImageModifier {
  171|       |
  172|       |    /// The alignment insets to apply to the image
  173|       |    public let alignmentInsets: UIEdgeInsets
  174|       |
  175|       |    /// Initialize a `AlignmentRectInsetsImageModifier`
  176|      0|    public init(alignmentInsets: UIEdgeInsets) {
  177|      0|        self.alignmentInsets = alignmentInsets
  178|      0|    }
  179|       |
  180|       |    /// Modify an input `Image`.
  181|       |    ///
  182|       |    /// - parameter image:   Image which will be modified by `self`
  183|       |    ///
  184|       |    /// - returns: The modified image.
  185|       |    ///
  186|       |    /// - Note: See documentation of `ImageModifier` protocol for more.
  187|      0|    public func modify(_ image: Image) -> Image {
  188|      0|        return image.withAlignmentRectInsets(alignmentInsets)
  189|      0|    }
  190|       |}
  191|       |#endif

/Users/raduj/Developer/Appub/Pods/Kingfisher/Sources/ImagePrefetcher.swift:
    1|       |//
    2|       |//  ImagePrefetcher.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Claire Knight <claire.knight@moggytech.co.uk> on 24/02/2016
    6|       |//
    7|       |//  Copyright (c) 2018 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |
   28|       |#if os(macOS)
   29|       |    import AppKit
   30|       |#else
   31|       |    import UIKit
   32|       |#endif
   33|       |
   34|       |
   35|       |/// Progress update block of prefetcher. 
   36|       |///
   37|       |/// - `skippedResources`: An array of resources that are already cached before the prefetching starting.
   38|       |/// - `failedResources`: An array of resources that fail to be downloaded. It could because of being cancelled while downloading, encountered an error when downloading or the download not being started at all.
   39|       |/// - `completedResources`: An array of resources that are downloaded and cached successfully.
   40|       |public typealias PrefetcherProgressBlock = ((_ skippedResources: [Resource], _ failedResources: [Resource], _ completedResources: [Resource]) -> Void)
   41|       |
   42|       |/// Completion block of prefetcher.
   43|       |///
   44|       |/// - `skippedResources`: An array of resources that are already cached before the prefetching starting.
   45|       |/// - `failedResources`: An array of resources that fail to be downloaded. It could because of being cancelled while downloading, encountered an error when downloading or the download not being started at all.
   46|       |/// - `completedResources`: An array of resources that are downloaded and cached successfully.
   47|       |public typealias PrefetcherCompletionHandler = ((_ skippedResources: [Resource], _ failedResources: [Resource], _ completedResources: [Resource]) -> Void)
   48|       |
   49|       |/// `ImagePrefetcher` represents a downloading manager for requesting many images via URLs, then caching them.
   50|       |/// This is useful when you know a list of image resources and want to download them before showing.
   51|       |public class ImagePrefetcher {
   52|       |    
   53|       |    /// The maximum concurrent downloads to use when prefetching images. Default is 5.
   54|       |    public var maxConcurrentDownloads = 5
   55|       |    
   56|       |    private let prefetchResources: [Resource]
   57|       |    private let optionsInfo: KingfisherOptionsInfo
   58|       |    private var progressBlock: PrefetcherProgressBlock?
   59|       |    private var completionHandler: PrefetcherCompletionHandler?
   60|       |    
   61|       |    private var tasks = [URL: RetrieveImageDownloadTask]()
   62|       |    
   63|       |    private var pendingResources: ArraySlice<Resource>
   64|       |    private var skippedResources = [Resource]()
   65|       |    private var completedResources = [Resource]()
   66|       |    private var failedResources = [Resource]()
   67|       |    
   68|       |    private var stopped = false
   69|       |    
   70|       |    // The created manager used for prefetch. We will use the helper method in manager.
   71|       |    private let manager: KingfisherManager
   72|       |    
   73|      0|    private var finished: Bool {
   74|      0|        return failedResources.count + skippedResources.count + completedResources.count == prefetchResources.count && self.tasks.isEmpty
   75|      0|    }
   76|       |    
   77|       |    /**
   78|       |     Init an image prefetcher with an array of URLs.
   79|       |     
   80|       |     The prefetcher should be initiated with a list of prefetching targets. The URLs list is immutable. 
   81|       |     After you get a valid `ImagePrefetcher` object, you could call `start()` on it to begin the prefetching process.
   82|       |     The images already cached will be skipped without downloading again.
   83|       |     
   84|       |     - parameter urls:              The URLs which should be prefetched.
   85|       |     - parameter options:           A dictionary could control some behaviors. See `KingfisherOptionsInfo` for more.
   86|       |     - parameter progressBlock:     Called every time an resource is downloaded, skipped or cancelled.
   87|       |     - parameter completionHandler: Called when the whole prefetching process finished.
   88|       |     
   89|       |     - returns: An `ImagePrefetcher` object.
   90|       |     
   91|       |     - Note: By default, the `ImageDownloader.defaultDownloader` and `ImageCache.defaultCache` will be used as 
   92|       |     the downloader and cache target respectively. You can specify another downloader or cache by using a customized `KingfisherOptionsInfo`.
   93|       |     Both the progress and completion block will be invoked in main thread. The `CallbackDispatchQueue` in `optionsInfo` will be ignored in this method.
   94|       |     */
   95|       |    public convenience init(urls: [URL],
   96|       |                         options: KingfisherOptionsInfo? = nil,
   97|       |                   progressBlock: PrefetcherProgressBlock? = nil,
   98|       |               completionHandler: PrefetcherCompletionHandler? = nil)
   99|      0|    {
  100|      0|        let resources: [Resource] = urls.map { $0 }
  101|      0|        self.init(resources: resources, options: options, progressBlock: progressBlock, completionHandler: completionHandler)
  102|      0|    }
  103|       |    
  104|       |    /**
  105|       |     Init an image prefetcher with an array of resources.
  106|       |     
  107|       |     The prefetcher should be initiated with a list of prefetching targets. The resources list is immutable.
  108|       |     After you get a valid `ImagePrefetcher` object, you could call `start()` on it to begin the prefetching process.
  109|       |     The images already cached will be skipped without downloading again.
  110|       |     
  111|       |     - parameter resources:         The resources which should be prefetched. See `Resource` type for more.
  112|       |     - parameter options:           A dictionary could control some behaviors. See `KingfisherOptionsInfo` for more.
  113|       |     - parameter progressBlock:     Called every time an resource is downloaded, skipped or cancelled.
  114|       |     - parameter completionHandler: Called when the whole prefetching process finished.
  115|       |     
  116|       |     - returns: An `ImagePrefetcher` object.
  117|       |     
  118|       |     - Note: By default, the `ImageDownloader.defaultDownloader` and `ImageCache.defaultCache` will be used as
  119|       |     the downloader and cache target respectively. You can specify another downloader or cache by using a customized `KingfisherOptionsInfo`.
  120|       |     Both the progress and completion block will be invoked in main thread. The `CallbackDispatchQueue` in `optionsInfo` will be ignored in this method.
  121|       |     */
  122|       |    public init(resources: [Resource],
  123|       |                  options: KingfisherOptionsInfo? = nil,
  124|       |            progressBlock: PrefetcherProgressBlock? = nil,
  125|       |        completionHandler: PrefetcherCompletionHandler? = nil)
  126|      0|    {
  127|      0|        prefetchResources = resources
  128|      0|        pendingResources = ArraySlice(resources)
  129|      0|        
  130|      0|        // We want all callbacks from main queue, so we ignore the call back queue in options
  131|      0|        let optionsInfoWithoutQueue = options?.removeAllMatchesIgnoringAssociatedValue(.callbackDispatchQueue(nil))
  132|      0|        self.optionsInfo = optionsInfoWithoutQueue ?? KingfisherEmptyOptionsInfo
  133|      0|        
  134|      0|        let cache = self.optionsInfo.targetCache
  135|      0|        let downloader = self.optionsInfo.downloader
  136|      0|        manager = KingfisherManager(downloader: downloader, cache: cache)
  137|      0|        
  138|      0|        self.progressBlock = progressBlock
  139|      0|        self.completionHandler = completionHandler
  140|      0|    }
  141|       |    
  142|       |    /**
  143|       |     Start to download the resources and cache them. This can be useful for background downloading
  144|       |     of assets that are required for later use in an app. This code will not try and update any UI
  145|       |     with the results of the process.
  146|       |     */
  147|       |    public func start()
  148|      0|    {
  149|      0|        // Since we want to handle the resources cancellation in main thread only.
  150|      0|        DispatchQueue.main.safeAsync {
  151|      0|            
  152|      0|            guard !self.stopped else {
  153|      0|                assertionFailure("You can not restart the same prefetcher. Try to create a new prefetcher.")
  154|      0|                self.handleComplete()
  155|      0|                return
  156|      0|            }
  157|      0|            
  158|      0|            guard self.maxConcurrentDownloads > 0 else {
  159|      0|                assertionFailure("There should be concurrent downloads value should be at least 1.")
  160|      0|                self.handleComplete()
  161|      0|                return
  162|      0|            }
  163|      0|            
  164|      0|            guard self.prefetchResources.count > 0 else {
  165|      0|                self.handleComplete()
  166|      0|                return
  167|      0|            }
  168|      0|            
  169|      0|            let initialConcurentDownloads = min(self.prefetchResources.count, self.maxConcurrentDownloads)
  170|      0|            for _ in 0 ..< initialConcurentDownloads {
  171|      0|                if let resource = self.pendingResources.popFirst() {
  172|      0|                    self.startPrefetching(resource)
  173|      0|                }
  174|      0|            }
  175|      0|        }
  176|      0|    }
  177|       |
  178|       |   
  179|       |    /**
  180|       |     Stop current downloading progress, and cancel any future prefetching activity that might be occuring.
  181|       |     */
  182|      0|    public func stop() {
  183|      0|        DispatchQueue.main.safeAsync {
  184|      0|            if self.finished { return }
  185|      0|            self.stopped = true
  186|      0|            self.tasks.values.forEach { $0.cancel() }
  187|      0|        }
  188|      0|    }
  189|       |    
  190|      0|    func downloadAndCache(_ resource: Resource) {
  191|      0|
  192|      0|        let downloadTaskCompletionHandler: CompletionHandler = { (image, error, _, _) -> Void in
  193|      0|            self.tasks.removeValue(forKey: resource.downloadURL)
  194|      0|            if let _ = error {
  195|      0|                self.failedResources.append(resource)
  196|      0|            } else {
  197|      0|                self.completedResources.append(resource)
  198|      0|            }
  199|      0|            
  200|      0|            self.reportProgress()
  201|      0|            if self.stopped {
  202|      0|                if self.tasks.isEmpty {
  203|      0|                    self.failedResources.append(contentsOf: self.pendingResources)
  204|      0|                    self.handleComplete()
  205|      0|                }
  206|      0|            } else {
  207|      0|                self.reportCompletionOrStartNext()
  208|      0|            }
  209|      0|        }
  210|      0|        
  211|      0|        let downloadTask = manager.downloadAndCacheImage(
  212|      0|            with: resource.downloadURL,
  213|      0|            forKey: resource.cacheKey,
  214|      0|            retrieveImageTask: RetrieveImageTask(),
  215|      0|            progressBlock: nil,
  216|      0|            completionHandler: downloadTaskCompletionHandler,
  217|      0|            options: optionsInfo)
  218|      0|        
  219|      0|        if let downloadTask = downloadTask {
  220|      0|            tasks[resource.downloadURL] = downloadTask
  221|      0|        }
  222|      0|    }
  223|       |    
  224|      0|    func append(cached resource: Resource) {
  225|      0|        skippedResources.append(resource)
  226|      0| 
  227|      0|        reportProgress()
  228|      0|        reportCompletionOrStartNext()
  229|      0|    }
  230|       |    
  231|       |    func startPrefetching(_ resource: Resource)
  232|      0|    {
  233|      0|        if optionsInfo.forceRefresh {
  234|      0|            downloadAndCache(resource)
  235|      0|        } else {
  236|      0|            let alreadyInCache = manager.cache.imageCachedType(forKey: resource.cacheKey,
  237|      0|                                                             processorIdentifier: optionsInfo.processor.identifier).cached
  238|      0|            if alreadyInCache {
  239|      0|                append(cached: resource)
  240|      0|            } else {
  241|      0|                downloadAndCache(resource)
  242|      0|            }
  243|      0|        }
  244|      0|    }
  245|       |    
  246|      0|    func reportProgress() {
  247|      0|        progressBlock?(skippedResources, failedResources, completedResources)
  248|      0|    }
  249|       |    
  250|      0|    func reportCompletionOrStartNext() {
  251|      0|        DispatchQueue.main.async {
  252|      0|            if let resource = self.pendingResources.popFirst() {
  253|      0|                self.startPrefetching(resource)
  254|      0|            } else {
  255|      0|                guard self.tasks.isEmpty else { return }
  256|      0|                self.handleComplete()
  257|      0|            }
  258|      0|        }
  259|      0|    }
  260|       |    
  261|      0|    func handleComplete() {
  262|      0|        completionHandler?(skippedResources, failedResources, completedResources)
  263|      0|        completionHandler = nil
  264|      0|        progressBlock = nil
  265|      0|    }
  266|       |}

/Users/raduj/Developer/Appub/Pods/Kingfisher/Sources/ImageProcessor.swift:
    1|       |//
    2|       |//  ImageProcessor.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 2016/08/26.
    6|       |//
    7|       |//  Copyright (c) 2018 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import Foundation
   28|       |import CoreGraphics
   29|       |
   30|       |#if os(macOS)
   31|       |import AppKit
   32|       |#endif
   33|       |
   34|       |/// The item which could be processed by an `ImageProcessor`
   35|       |///
   36|       |/// - image: Input image
   37|       |/// - data:  Input data
   38|       |public enum ImageProcessItem {
   39|       |    case image(Image)
   40|       |    case data(Data)
   41|       |}
   42|       |
   43|       |/// An `ImageProcessor` would be used to convert some downloaded data to an image.
   44|       |public protocol ImageProcessor {
   45|       |    /// Identifier of the processor. It will be used to identify the processor when 
   46|       |    /// caching and retrieving an image. You might want to make sure that processors with
   47|       |    /// same properties/functionality have the same identifiers, so correct processed images
   48|       |    /// could be retrieved with proper key.
   49|       |    /// 
   50|       |    /// - Note: Do not supply an empty string for a customized processor, which is already taken by
   51|       |    /// the `DefaultImageProcessor`. It is recommended to use a reverse domain name notation
   52|       |    /// string of your own for the identifier.
   53|       |    var identifier: String { get }
   54|       |    
   55|       |    /// Process an input `ImageProcessItem` item to an image for this processor.
   56|       |    ///
   57|       |    /// - parameter item:    Input item which will be processed by `self`
   58|       |    /// - parameter options: Options when processing the item.
   59|       |    ///
   60|       |    /// - returns: The processed image.
   61|       |    ///
   62|       |    /// - Note: The return value will be `nil` if processing failed while converting data to image.
   63|       |    ///         If input item is already an image and there is any errors in processing, the input 
   64|       |    ///         image itself will be returned.
   65|       |    /// - Note: Most processor only supports CG-based images. 
   66|       |    ///         watchOS is not supported for processors containing filter, the input image will be returned directly on watchOS.
   67|       |    func process(item: ImageProcessItem, options: KingfisherOptionsInfo) -> Image?
   68|       |}
   69|       |
   70|       |typealias ProcessorImp = ((ImageProcessItem, KingfisherOptionsInfo) -> Image?)
   71|       |
   72|       |public extension ImageProcessor {
   73|       |    
   74|       |    /// Append an `ImageProcessor` to another. The identifier of the new `ImageProcessor` 
   75|       |    /// will be "\(self.identifier)|>\(another.identifier)".
   76|       |    ///
   77|       |    /// - parameter another: An `ImageProcessor` you want to append to `self`.
   78|       |    ///
   79|       |    /// - returns: The new `ImageProcessor` will process the image in the order
   80|       |    ///            of the two processors concatenated.
   81|      0|    public func append(another: ImageProcessor) -> ImageProcessor {
   82|      0|        let newIdentifier = identifier.appending("|>\(another.identifier)")
   83|      0|        return GeneralProcessor(identifier: newIdentifier) {
   84|      0|            item, options in
   85|      0|            if let image = self.process(item: item, options: options) {
   86|      0|                return another.process(item: .image(image), options: options)
   87|      0|            } else {
   88|      0|                return nil
   89|      0|            }
   90|      0|        }
   91|      0|    }
   92|       |}
   93|       |
   94|      0|func ==(left: ImageProcessor, right: ImageProcessor) -> Bool {
   95|      0|    return left.identifier == right.identifier
   96|      0|}
   97|       |
   98|      0|func !=(left: ImageProcessor, right: ImageProcessor) -> Bool {
   99|      0|    return !(left == right)
  100|      0|}
  101|       |
  102|       |fileprivate struct GeneralProcessor: ImageProcessor {
  103|       |    let identifier: String
  104|       |    let p: ProcessorImp
  105|      0|    func process(item: ImageProcessItem, options: KingfisherOptionsInfo) -> Image? {
  106|      0|        return p(item, options)
  107|      0|    }
  108|       |}
  109|       |
  110|       |/// The default processor. It convert the input data to a valid image.
  111|       |/// Images of .PNG, .JPEG and .GIF format are supported.
  112|       |/// If an image is given, `DefaultImageProcessor` will do nothing on it and just return that image.
  113|       |public struct DefaultImageProcessor: ImageProcessor {
  114|       |    
  115|       |    /// A default `DefaultImageProcessor` could be used across.
  116|       |    public static let `default` = DefaultImageProcessor()
  117|       |    
  118|       |    /// Identifier of the processor.
  119|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  120|       |    public let identifier = ""
  121|       |    
  122|       |    /// Initialize a `DefaultImageProcessor`
  123|      0|    public init() {}
  124|       |    
  125|       |    /// Process an input `ImageProcessItem` item to an image for this processor.
  126|       |    ///
  127|       |    /// - parameter item:    Input item which will be processed by `self`
  128|       |    /// - parameter options: Options when processing the item.
  129|       |    ///
  130|       |    /// - returns: The processed image.
  131|       |    /// 
  132|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  133|      0|    public func process(item: ImageProcessItem, options: KingfisherOptionsInfo) -> Image? {
  134|      0|        switch item {
  135|      0|        case .image(let image):
  136|      0|            return image.kf.scaled(to: options.scaleFactor)
  137|      0|        case .data(let data):
  138|      0|            return Kingfisher<Image>.image(
  139|      0|                data: data,
  140|      0|                scale: options.scaleFactor,
  141|      0|                preloadAllAnimationData: options.preloadAllAnimationData,
  142|      0|                onlyFirstFrame: options.onlyLoadFirstFrame)
  143|      0|        }
  144|      0|    }
  145|       |}
  146|       |
  147|       |public struct RectCorner: OptionSet {
  148|       |    public let rawValue: Int
  149|       |    public static let topLeft = RectCorner(rawValue: 1 << 0)
  150|       |    public static let topRight = RectCorner(rawValue: 1 << 1)
  151|       |    public static let bottomLeft = RectCorner(rawValue: 1 << 2)
  152|       |    public static let bottomRight = RectCorner(rawValue: 1 << 3)
  153|       |    public static let all: RectCorner = [.topLeft, .topRight, .bottomLeft, .bottomRight]
  154|       |    
  155|      0|    public init(rawValue: Int) {
  156|      0|        self.rawValue = rawValue
  157|      0|    }
  158|       |    
  159|      0|    var cornerIdentifier: String {
  160|      0|        if self == .all {
  161|      0|            return ""
  162|      0|        }
  163|      0|        return "_corner(\(rawValue))"
  164|      0|    }
  165|       |}
  166|       |
  167|       |#if !os(macOS)
  168|       |/// Processor for adding an blend mode to images. Only CG-based images are supported.
  169|       |public struct BlendImageProcessor: ImageProcessor {
  170|       |
  171|       |    /// Identifier of the processor.
  172|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  173|       |    public let identifier: String
  174|       |
  175|       |    /// Blend Mode will be used to blend the input image.
  176|       |    public let blendMode: CGBlendMode
  177|       |    /// Alpha will be used when blend image.
  178|       |    public let alpha: CGFloat
  179|       |
  180|       |    /// Background color of the output image. If `nil`, it will stay transparent.
  181|       |    public let backgroundColor: Color?
  182|       |
  183|       |    /// Initialize an `BlendImageProcessor`
  184|       |    ///
  185|       |    /// - parameter blendMode:       Blend Mode will be used to blend the input image.
  186|       |    /// - parameter alpha:           Alpha will be used when blend image.
  187|       |    ///                              From 0.0 to 1.0. 1.0 means solid image, 0.0 means transparent image.
  188|       |    ///                              Default is 1.0.
  189|       |    /// - parameter backgroundColor: Background color to apply for the output image. Default is `nil`.
  190|      0|    public init(blendMode: CGBlendMode, alpha: CGFloat = 1.0, backgroundColor: Color? = nil) {
  191|      0|        self.blendMode = blendMode
  192|      0|        self.alpha = alpha
  193|      0|        self.backgroundColor = backgroundColor
  194|      0|        var identifier = "com.onevcat.Kingfisher.BlendImageProcessor(\(blendMode.rawValue),\(alpha))"
  195|      0|        if let color = backgroundColor {
  196|      0|            identifier.append("_\(color.hex)")
  197|      0|        }
  198|      0|        self.identifier = identifier
  199|      0|    }
  200|       |
  201|       |    /// Process an input `ImageProcessItem` item to an image for this processor.
  202|       |    ///
  203|       |    /// - parameter item:    Input item which will be processed by `self`
  204|       |    /// - parameter options: Options when processing the item.
  205|       |    ///
  206|       |    /// - returns: The processed image.
  207|       |    ///
  208|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  209|      0|    public func process(item: ImageProcessItem, options: KingfisherOptionsInfo) -> Image? {
  210|      0|        switch item {
  211|      0|        case .image(let image):
  212|      0|            return image.kf.scaled(to: options.scaleFactor)
  213|      0|                        .kf.image(withBlendMode: blendMode, alpha: alpha, backgroundColor: backgroundColor)
  214|      0|        case .data(_):
  215|      0|            return (DefaultImageProcessor.default >> self).process(item: item, options: options)
  216|      0|        }
  217|      0|    }
  218|       |}
  219|       |#endif
  220|       |
  221|       |#if os(macOS)
  222|       |/// Processor for adding an compositing operation to images. Only CG-based images are supported in macOS.
  223|       |public struct CompositingImageProcessor: ImageProcessor {
  224|       |
  225|       |    /// Identifier of the processor.
  226|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  227|       |    public let identifier: String
  228|       |
  229|       |    /// Compositing operation will be used to the input image.
  230|       |    public let compositingOperation: NSCompositingOperation
  231|       |
  232|       |    /// Alpha will be used when compositing image.
  233|       |    public let alpha: CGFloat
  234|       |
  235|       |    /// Background color of the output image. If `nil`, it will stay transparent.
  236|       |    public let backgroundColor: Color?
  237|       |
  238|       |    /// Initialize an `CompositingImageProcessor`
  239|       |    ///
  240|       |    /// - parameter compositingOperation: Compositing operation will be used to the input image.
  241|       |    /// - parameter alpha:                Alpha will be used when compositing image.
  242|       |    ///                                   From 0.0 to 1.0. 1.0 means solid image, 0.0 means transparent image.
  243|       |    ///                                   Default is 1.0.
  244|       |    /// - parameter backgroundColor:      Background color to apply for the output image. Default is `nil`.
  245|       |    public init(compositingOperation: NSCompositingOperation,
  246|       |                alpha: CGFloat = 1.0,
  247|       |                backgroundColor: Color? = nil)
  248|       |    {
  249|       |        self.compositingOperation = compositingOperation
  250|       |        self.alpha = alpha
  251|       |        self.backgroundColor = backgroundColor
  252|       |        var identifier = "com.onevcat.Kingfisher.CompositingImageProcessor(\(compositingOperation.rawValue),\(alpha))"
  253|       |        if let color = backgroundColor {
  254|       |            identifier.append("_\(color.hex)")
  255|       |        }
  256|       |        self.identifier = identifier
  257|       |    }
  258|       |
  259|       |    /// Process an input `ImageProcessItem` item to an image for this processor.
  260|       |    ///
  261|       |    /// - parameter item:    Input item which will be processed by `self`
  262|       |    /// - parameter options: Options when processing the item.
  263|       |    ///
  264|       |    /// - returns: The processed image.
  265|       |    ///
  266|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  267|       |    public func process(item: ImageProcessItem, options: KingfisherOptionsInfo) -> Image? {
  268|       |        switch item {
  269|       |        case .image(let image):
  270|       |            return image.kf.scaled(to: options.scaleFactor)
  271|       |                        .kf.image(withCompositingOperation: compositingOperation, alpha: alpha, backgroundColor: backgroundColor)
  272|       |        case .data(_):
  273|       |            return (DefaultImageProcessor.default >> self).process(item: item, options: options)
  274|       |        }
  275|       |    }
  276|       |}
  277|       |#endif
  278|       |
  279|       |/// Processor for making round corner images. Only CG-based images are supported in macOS, 
  280|       |/// if a non-CG image passed in, the processor will do nothing.
  281|       |public struct RoundCornerImageProcessor: ImageProcessor {
  282|       |    
  283|       |    /// Identifier of the processor.
  284|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  285|       |    public let identifier: String
  286|       |
  287|       |    /// Corner radius will be applied in processing.
  288|       |    public let cornerRadius: CGFloat
  289|       |    
  290|       |    /// The target corners which will be applied rounding.
  291|       |    public let roundingCorners: RectCorner
  292|       |    
  293|       |    /// Target size of output image should be. If `nil`, the image will keep its original size after processing.
  294|       |    public let targetSize: CGSize?
  295|       |
  296|       |    /// Background color of the output image. If `nil`, it will stay transparent.
  297|       |    public let backgroundColor: Color?
  298|       |
  299|       |    /// Initialize a `RoundCornerImageProcessor`
  300|       |    ///
  301|       |    /// - parameter cornerRadius:    Corner radius will be applied in processing.
  302|       |    /// - parameter targetSize:      Target size of output image should be. If `nil`, 
  303|       |    ///                              the image will keep its original size after processing.
  304|       |    ///                              Default is `nil`.
  305|       |    /// - parameter corners:         The target corners which will be applied rounding. Default is `.all`.
  306|       |    /// - parameter backgroundColor: Background color to apply for the output image. Default is `nil`.
  307|      0|    public init(cornerRadius: CGFloat, targetSize: CGSize? = nil, roundingCorners corners: RectCorner = .all, backgroundColor: Color? = nil) {
  308|      0|        self.cornerRadius = cornerRadius
  309|      0|        self.targetSize = targetSize
  310|      0|        self.roundingCorners = corners
  311|      0|        self.backgroundColor = backgroundColor
  312|      0|
  313|      0|        self.identifier = {
  314|      0|            var identifier = ""
  315|      0|
  316|      0|            if let size = targetSize {
  317|      0|                identifier = "com.onevcat.Kingfisher.RoundCornerImageProcessor(\(cornerRadius)_\(size)\(corners.cornerIdentifier))"
  318|      0|            } else {
  319|      0|                identifier = "com.onevcat.Kingfisher.RoundCornerImageProcessor(\(cornerRadius)\(corners.cornerIdentifier))"
  320|      0|            }
  321|      0|            if let backgroundColor = backgroundColor {
  322|      0|                identifier += "_\(backgroundColor)"
  323|      0|            }
  324|      0|
  325|      0|            return identifier
  326|      0|        }()
  327|      0|    }
  328|       |    
  329|       |    /// Process an input `ImageProcessItem` item to an image for this processor.
  330|       |    ///
  331|       |    /// - parameter item:    Input item which will be processed by `self`
  332|       |    /// - parameter options: Options when processing the item.
  333|       |    ///
  334|       |    /// - returns: The processed image.
  335|       |    ///
  336|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  337|      0|    public func process(item: ImageProcessItem, options: KingfisherOptionsInfo) -> Image? {
  338|      0|        switch item {
  339|      0|        case .image(let image):
  340|      0|            let size = targetSize ?? image.kf.size
  341|      0|            return image.kf.scaled(to: options.scaleFactor)
  342|      0|                        .kf.image(withRoundRadius: cornerRadius, fit: size, roundingCorners: roundingCorners, backgroundColor: backgroundColor)
  343|      0|        case .data(_):
  344|      0|            return (DefaultImageProcessor.default >> self).process(item: item, options: options)
  345|      0|        }
  346|      0|    }
  347|       |}
  348|       |
  349|       |
  350|       |/// Specify how a size adjusts itself to fit a target size.
  351|       |///
  352|       |/// - none: Not scale the content.
  353|       |/// - aspectFit: Scale the content to fit the size of the view by maintaining the aspect ratio.
  354|       |/// - aspectFill: Scale the content to fill the size of the view
  355|       |public enum ContentMode {
  356|       |    case none
  357|       |    case aspectFit
  358|       |    case aspectFill
  359|       |}
  360|       |
  361|       |/// Processor for resizing images. Only CG-based images are supported in macOS.
  362|       |public struct ResizingImageProcessor: ImageProcessor {
  363|       |    
  364|       |    /// Identifier of the processor.
  365|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  366|       |    public let identifier: String
  367|       |    
  368|       |    /// The reference size for resizing operation.
  369|       |    public let referenceSize: CGSize
  370|       |    
  371|       |    /// Target content mode of output image should be.
  372|       |    /// Default to ContentMode.none
  373|       |    public let targetContentMode: ContentMode
  374|       |    
  375|       |    /// Initialize a `ResizingImageProcessor`.
  376|       |    ///
  377|       |    /// - Parameters:
  378|       |    ///   - referenceSize: The reference size for resizing operation.
  379|       |    ///   - mode: Target content mode of output image should be.
  380|       |    ///
  381|       |    /// - Note:
  382|       |    ///   The instance of `ResizingImageProcessor` will follow its `mode` property
  383|       |    ///   and try to resizing the input images to fit or fill the `referenceSize`.
  384|       |    ///   That means if you are using a `mode` besides of `.none`, you may get an
  385|       |    ///   image with its size not be the same as the `referenceSize`.
  386|       |    ///
  387|       |    ///   **Example**: With input image size: {100, 200}, 
  388|       |    ///   `referenceSize`: {100, 100}, `mode`: `.aspectFit`,
  389|       |    ///   you will get an output image with size of {50, 100}, which "fit"s
  390|       |    ///   the `referenceSize`.
  391|       |    ///
  392|       |    ///   If you need an output image exactly to be a specified size, append or use
  393|       |    ///   a `CroppingImageProcessor`.
  394|      0|    public init(referenceSize: CGSize, mode: ContentMode = .none) {
  395|      0|        self.referenceSize = referenceSize
  396|      0|        self.targetContentMode = mode
  397|      0|        
  398|      0|        if mode == .none {
  399|      0|            self.identifier = "com.onevcat.Kingfisher.ResizingImageProcessor(\(referenceSize))"
  400|      0|        } else {
  401|      0|            self.identifier = "com.onevcat.Kingfisher.ResizingImageProcessor(\(referenceSize), \(mode))"
  402|      0|        }
  403|      0|    }
  404|       |    
  405|       |    /// Process an input `ImageProcessItem` item to an image for this processor.
  406|       |    ///
  407|       |    /// - parameter item:    Input item which will be processed by `self`
  408|       |    /// - parameter options: Options when processing the item.
  409|       |    ///
  410|       |    /// - returns: The processed image.
  411|       |    ///
  412|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  413|      0|    public func process(item: ImageProcessItem, options: KingfisherOptionsInfo) -> Image? {
  414|      0|        switch item {
  415|      0|        case .image(let image):
  416|      0|            return image.kf.scaled(to: options.scaleFactor)
  417|      0|                        .kf.resize(to: referenceSize, for: targetContentMode)
  418|      0|        case .data(_):
  419|      0|            return (DefaultImageProcessor.default >> self).process(item: item, options: options)
  420|      0|        }
  421|      0|    }
  422|       |}
  423|       |
  424|       |/// Processor for adding blur effect to images. `Accelerate.framework` is used underhood for 
  425|       |/// a better performance. A simulated Gaussian blur with specified blur radius will be applied.
  426|       |public struct BlurImageProcessor: ImageProcessor {
  427|       |    
  428|       |    /// Identifier of the processor.
  429|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  430|       |    public let identifier: String
  431|       |    
  432|       |    /// Blur radius for the simulated Gaussian blur.
  433|       |    public let blurRadius: CGFloat
  434|       |
  435|       |    /// Initialize a `BlurImageProcessor`
  436|       |    ///
  437|       |    /// - parameter blurRadius: Blur radius for the simulated Gaussian blur.
  438|      0|    public init(blurRadius: CGFloat) {
  439|      0|        self.blurRadius = blurRadius
  440|      0|        self.identifier = "com.onevcat.Kingfisher.BlurImageProcessor(\(blurRadius))"
  441|      0|    }
  442|       |    
  443|       |    /// Process an input `ImageProcessItem` item to an image for this processor.
  444|       |    ///
  445|       |    /// - parameter item:    Input item which will be processed by `self`
  446|       |    /// - parameter options: Options when processing the item.
  447|       |    ///
  448|       |    /// - returns: The processed image.
  449|       |    ///
  450|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  451|      0|    public func process(item: ImageProcessItem, options: KingfisherOptionsInfo) -> Image? {
  452|      0|        switch item {
  453|      0|        case .image(let image):
  454|      0|            let radius = blurRadius * options.scaleFactor
  455|      0|            return image.kf.scaled(to: options.scaleFactor)
  456|      0|                        .kf.blurred(withRadius: radius)
  457|      0|        case .data(_):
  458|      0|            return (DefaultImageProcessor.default >> self).process(item: item, options: options)
  459|      0|        }
  460|      0|    }
  461|       |}
  462|       |
  463|       |/// Processor for adding an overlay to images. Only CG-based images are supported in macOS.
  464|       |public struct OverlayImageProcessor: ImageProcessor {
  465|       |    
  466|       |    /// Identifier of the processor.
  467|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  468|       |    public let identifier: String
  469|       |    
  470|       |    /// Overlay color will be used to overlay the input image.
  471|       |    public let overlay: Color
  472|       |    
  473|       |    /// Fraction will be used when overlay the color to image.
  474|       |    public let fraction: CGFloat
  475|       |    
  476|       |    /// Initialize an `OverlayImageProcessor`
  477|       |    ///
  478|       |    /// - parameter overlay:  Overlay color will be used to overlay the input image.
  479|       |    /// - parameter fraction: Fraction will be used when overlay the color to image. 
  480|       |    ///                       From 0.0 to 1.0. 0.0 means solid color, 1.0 means transparent overlay.
  481|      0|    public init(overlay: Color, fraction: CGFloat = 0.5) {
  482|      0|        self.overlay = overlay
  483|      0|        self.fraction = fraction
  484|      0|        self.identifier = "com.onevcat.Kingfisher.OverlayImageProcessor(\(overlay.hex)_\(fraction))"
  485|      0|    }
  486|       |    
  487|       |    /// Process an input `ImageProcessItem` item to an image for this processor.
  488|       |    ///
  489|       |    /// - parameter item:    Input item which will be processed by `self`
  490|       |    /// - parameter options: Options when processing the item.
  491|       |    ///
  492|       |    /// - returns: The processed image.
  493|       |    ///
  494|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  495|      0|    public func process(item: ImageProcessItem, options: KingfisherOptionsInfo) -> Image? {
  496|      0|        switch item {
  497|      0|        case .image(let image):
  498|      0|            return image.kf.scaled(to: options.scaleFactor)
  499|      0|                        .kf.overlaying(with: overlay, fraction: fraction)
  500|      0|        case .data(_):
  501|      0|            return (DefaultImageProcessor.default >> self).process(item: item, options: options)
  502|      0|        }
  503|      0|    }
  504|       |}
  505|       |
  506|       |/// Processor for tint images with color. Only CG-based images are supported.
  507|       |public struct TintImageProcessor: ImageProcessor {
  508|       |    
  509|       |    /// Identifier of the processor.
  510|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  511|       |    public let identifier: String
  512|       |    
  513|       |    /// Tint color will be used to tint the input image.
  514|       |    public let tint: Color
  515|       |    
  516|       |    /// Initialize a `TintImageProcessor`
  517|       |    ///
  518|       |    /// - parameter tint: Tint color will be used to tint the input image.
  519|      0|    public init(tint: Color) {
  520|      0|        self.tint = tint
  521|      0|        self.identifier = "com.onevcat.Kingfisher.TintImageProcessor(\(tint.hex))"
  522|      0|    }
  523|       |    
  524|       |    /// Process an input `ImageProcessItem` item to an image for this processor.
  525|       |    ///
  526|       |    /// - parameter item:    Input item which will be processed by `self`
  527|       |    /// - parameter options: Options when processing the item.
  528|       |    ///
  529|       |    /// - returns: The processed image.
  530|       |    ///
  531|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  532|      0|    public func process(item: ImageProcessItem, options: KingfisherOptionsInfo) -> Image? {
  533|      0|        switch item {
  534|      0|        case .image(let image):
  535|      0|            return image.kf.scaled(to: options.scaleFactor)
  536|      0|                        .kf.tinted(with: tint)
  537|      0|        case .data(_):
  538|      0|            return (DefaultImageProcessor.default >> self).process(item: item, options: options)
  539|      0|        }
  540|      0|    }
  541|       |}
  542|       |
  543|       |/// Processor for applying some color control to images. Only CG-based images are supported.
  544|       |/// watchOS is not supported.
  545|       |public struct ColorControlsProcessor: ImageProcessor {
  546|       |    
  547|       |    /// Identifier of the processor.
  548|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  549|       |    public let identifier: String
  550|       |    
  551|       |    /// Brightness changing to image.
  552|       |    public let brightness: CGFloat
  553|       |    
  554|       |    /// Contrast changing to image.
  555|       |    public let contrast: CGFloat
  556|       |    
  557|       |    /// Saturation changing to image.
  558|       |    public let saturation: CGFloat
  559|       |    
  560|       |    /// InputEV changing to image.
  561|       |    public let inputEV: CGFloat
  562|       |    
  563|       |    /// Initialize a `ColorControlsProcessor`
  564|       |    ///
  565|       |    /// - parameter brightness: Brightness changing to image.
  566|       |    /// - parameter contrast:   Contrast changing to image.
  567|       |    /// - parameter saturation: Saturation changing to image.
  568|       |    /// - parameter inputEV:    InputEV changing to image.
  569|      0|    public init(brightness: CGFloat, contrast: CGFloat, saturation: CGFloat, inputEV: CGFloat) {
  570|      0|        self.brightness = brightness
  571|      0|        self.contrast = contrast
  572|      0|        self.saturation = saturation
  573|      0|        self.inputEV = inputEV
  574|      0|        self.identifier = "com.onevcat.Kingfisher.ColorControlsProcessor(\(brightness)_\(contrast)_\(saturation)_\(inputEV))"
  575|      0|    }
  576|       |    
  577|       |    /// Process an input `ImageProcessItem` item to an image for this processor.
  578|       |    ///
  579|       |    /// - parameter item:    Input item which will be processed by `self`
  580|       |    /// - parameter options: Options when processing the item.
  581|       |    ///
  582|       |    /// - returns: The processed image.
  583|       |    ///
  584|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  585|      0|    public func process(item: ImageProcessItem, options: KingfisherOptionsInfo) -> Image? {
  586|      0|        switch item {
  587|      0|        case .image(let image):
  588|      0|            return image.kf.scaled(to: options.scaleFactor)
  589|      0|                        .kf.adjusted(brightness: brightness, contrast: contrast, saturation: saturation, inputEV: inputEV)
  590|      0|        case .data(_):
  591|      0|            return (DefaultImageProcessor.default >> self).process(item: item, options: options)
  592|      0|        }
  593|      0|    }
  594|       |}
  595|       |
  596|       |/// Processor for applying black and white effect to images. Only CG-based images are supported.
  597|       |/// watchOS is not supported.
  598|       |public struct BlackWhiteProcessor: ImageProcessor {
  599|       |    
  600|       |    /// Identifier of the processor.
  601|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  602|       |    public let identifier = "com.onevcat.Kingfisher.BlackWhiteProcessor"
  603|       |    
  604|       |    /// Initialize a `BlackWhiteProcessor`
  605|      0|    public init() {}
  606|       |    
  607|       |    /// Process an input `ImageProcessItem` item to an image for this processor.
  608|       |    ///
  609|       |    /// - parameter item:    Input item which will be processed by `self`
  610|       |    /// - parameter options: Options when processing the item.
  611|       |    ///
  612|       |    /// - returns: The processed image.
  613|       |    ///
  614|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  615|      0|    public func process(item: ImageProcessItem, options: KingfisherOptionsInfo) -> Image? {
  616|      0|        return ColorControlsProcessor(brightness: 0.0, contrast: 1.0, saturation: 0.0, inputEV: 0.7)
  617|      0|            .process(item: item, options: options)
  618|      0|    }
  619|       |}
  620|       |
  621|       |/// Processor for cropping an image. Only CG-based images are supported.
  622|       |/// watchOS is not supported.
  623|       |public struct CroppingImageProcessor: ImageProcessor {
  624|       |    
  625|       |    /// Identifier of the processor.
  626|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  627|       |    public let identifier: String
  628|       |    
  629|       |    /// Target size of output image should be.
  630|       |    public let size: CGSize
  631|       |    
  632|       |    /// Anchor point from which the output size should be calculate.
  633|       |    /// The anchor point is consisted by two values between 0.0 and 1.0.
  634|       |    /// It indicates a related point in current image. 
  635|       |    /// See `CroppingImageProcessor.init(size:anchor:)` for more.
  636|       |    public let anchor: CGPoint
  637|       |    
  638|       |    /// Initialize a `CroppingImageProcessor`
  639|       |    ///
  640|       |    /// - Parameters:
  641|       |    ///   - size: Target size of output image should be.
  642|       |    ///   - anchor: The anchor point from which the size should be calculated.
  643|       |    ///             Default is `CGPoint(x: 0.5, y: 0.5)`, which means the center of input image.
  644|       |    /// - Note:
  645|       |    ///   The anchor point is consisted by two values between 0.0 and 1.0.
  646|       |    ///   It indicates a related point in current image, eg: (0.0, 0.0) for top-left
  647|       |    ///   corner, (0.5, 0.5) for center and (1.0, 1.0) for bottom-right corner.
  648|       |    ///   The `size` property of `CroppingImageProcessor` will be used along with
  649|       |    ///   `anchor` to calculate a target rectangle in the size of image.
  650|       |    ///    
  651|       |    ///   The target size will be automatically calculated with a reasonable behavior.
  652|       |    ///   For example, when you have an image size of `CGSize(width: 100, height: 100)`,
  653|       |    ///   and a target size of `CGSize(width: 20, height: 20)`: 
  654|       |    ///   - with a (0.0, 0.0) anchor (top-left), the crop rect will be `{0, 0, 20, 20}`; 
  655|       |    ///   - with a (0.5, 0.5) anchor (center), it will be `{40, 40, 20, 20}`
  656|       |    ///   - while with a (1.0, 1.0) anchor (bottom-right), it will be `{80, 80, 20, 20}`
  657|      0|    public init(size: CGSize, anchor: CGPoint = CGPoint(x: 0.5, y: 0.5)) {
  658|      0|        self.size = size
  659|      0|        self.anchor = anchor
  660|      0|        self.identifier = "com.onevcat.Kingfisher.CroppingImageProcessor(\(size)_\(anchor))"
  661|      0|    }
  662|       |    
  663|       |    /// Process an input `ImageProcessItem` item to an image for this processor.
  664|       |    ///
  665|       |    /// - parameter item:    Input item which will be processed by `self`
  666|       |    /// - parameter options: Options when processing the item.
  667|       |    ///
  668|       |    /// - returns: The processed image.
  669|       |    ///
  670|       |    /// - Note: See documentation of `ImageProcessor` protocol for more.
  671|      0|    public func process(item: ImageProcessItem, options: KingfisherOptionsInfo) -> Image? {
  672|      0|        switch item {
  673|      0|        case .image(let image):
  674|      0|            return image.kf.scaled(to: options.scaleFactor)
  675|      0|                        .kf.crop(to: size, anchorOn: anchor)
  676|      0|        case .data(_): return (DefaultImageProcessor.default >> self).process(item: item, options: options)
  677|      0|        }
  678|      0|    }
  679|       |}
  680|       |
  681|       |/// Concatenate two `ImageProcessor`s. `ImageProcessor.appen(another:)` is used internally.
  682|       |///
  683|       |/// - parameter left:  First processor.
  684|       |/// - parameter right: Second processor.
  685|       |///
  686|       |/// - returns: The concatenated processor.
  687|       |public func >>(left: ImageProcessor, right: ImageProcessor) -> ImageProcessor {
  688|       |    return left.append(another: right)
  689|       |}
  690|       |
  691|       |extension Color {
  692|       |    var hex: String {
  693|       |        var r: CGFloat = 0
  694|       |        var g: CGFloat = 0
  695|       |        var b: CGFloat = 0
  696|       |        var a: CGFloat = 0
  697|       |
  698|       |        #if os(macOS)
  699|       |        (usingColorSpace(.sRGB) ?? self).getRed(&r, green: &g, blue: &b, alpha: &a)
  700|       |        #else
  701|       |        getRed(&r, green: &g, blue: &b, alpha: &a)
  702|       |        #endif
  703|       |
  704|       |        let rInt = Int(r * 255) << 24
  705|       |        let gInt = Int(g * 255) << 16
  706|       |        let bInt = Int(b * 255) << 8
  707|       |        let aInt = Int(a * 255)
  708|       |        
  709|       |        let rgba = rInt | gInt | bInt | aInt
  710|       |        
  711|       |        return String(format:"#%08x", rgba)
  712|       |    }
  713|       |}

/Users/raduj/Developer/Appub/Pods/Kingfisher/Sources/ImageTransition.swift:
    1|       |//
    2|       |//  ImageTransition.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 15/9/18.
    6|       |//
    7|       |//  Copyright (c) 2018 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |#if os(macOS)
   28|       |// Not implemented for macOS and watchOS yet.
   29|       |    
   30|       |import AppKit
   31|       |
   32|       |/// Image transition is not supported on macOS.
   33|       |public enum ImageTransition {
   34|       |    case none
   35|       |    var duration: TimeInterval {
   36|       |        return 0
   37|       |    }
   38|       |}
   39|       |
   40|       |#elseif os(watchOS)
   41|       |import UIKit
   42|       |/// Image transition is not supported on watchOS.
   43|       |public enum ImageTransition {
   44|       |    case none
   45|       |    var duration: TimeInterval {
   46|       |        return 0
   47|       |    }
   48|       |}
   49|       |#else
   50|       |import UIKit
   51|       |
   52|       |/**
   53|       |Transition effect which will be used when an image downloaded and set by `UIImageView` extension API in Kingfisher.
   54|       |You can assign an enum value with transition duration as an item in `KingfisherOptionsInfo` 
   55|       |to enable the animation transition.
   56|       |
   57|       |Apple's UIViewAnimationOptions is used under the hood.
   58|       |For custom transition, you should specified your own transition options, animations and 
   59|       |completion handler as well.
   60|       |*/
   61|       |public enum ImageTransition {
   62|       |    ///  No animation transition.
   63|       |    case none
   64|       |    
   65|       |    /// Fade in the loaded image.
   66|       |    case fade(TimeInterval)
   67|       |
   68|       |    /// Flip from left transition.
   69|       |    case flipFromLeft(TimeInterval)
   70|       |
   71|       |    /// Flip from right transition.
   72|       |    case flipFromRight(TimeInterval)
   73|       |    
   74|       |    /// Flip from top transition.
   75|       |    case flipFromTop(TimeInterval)
   76|       |    
   77|       |    /// Flip from bottom transition.
   78|       |    case flipFromBottom(TimeInterval)
   79|       |    
   80|       |    /// Custom transition.
   81|       |    case custom(duration: TimeInterval,
   82|       |                 options: UIViewAnimationOptions,
   83|       |              animations: ((UIImageView, UIImage) -> Void)?,
   84|       |              completion: ((Bool) -> Void)?)
   85|       |    
   86|      0|    var duration: TimeInterval {
   87|      0|        switch self {
   88|      0|        case .none:                          return 0
   89|      0|        case .fade(let duration):            return duration
   90|      0|            
   91|      0|        case .flipFromLeft(let duration):    return duration
   92|      0|        case .flipFromRight(let duration):   return duration
   93|      0|        case .flipFromTop(let duration):     return duration
   94|      0|        case .flipFromBottom(let duration):  return duration
   95|      0|            
   96|      0|        case .custom(let duration, _, _, _): return duration
   97|      0|        }
   98|      0|    }
   99|       |    
  100|      0|    var animationOptions: UIViewAnimationOptions {
  101|      0|        switch self {
  102|      0|        case .none:                         return []
  103|      0|        case .fade(_):                      return .transitionCrossDissolve
  104|      0|            
  105|      0|        case .flipFromLeft(_):              return .transitionFlipFromLeft
  106|      0|        case .flipFromRight(_):             return .transitionFlipFromRight
  107|      0|        case .flipFromTop(_):               return .transitionFlipFromTop
  108|      0|        case .flipFromBottom(_):            return .transitionFlipFromBottom
  109|      0|            
  110|      0|        case .custom(_, let options, _, _): return options
  111|      0|        }
  112|      0|    }
  113|       |    
  114|      0|    var animations: ((UIImageView, UIImage) -> Void)? {
  115|      0|        switch self {
  116|      0|        case .custom(_, _, let animations, _): return animations
  117|      0|        default: return { $0.image = $1 }
  118|      0|        }
  119|      0|    }
  120|       |    
  121|      0|    var completion: ((Bool) -> Void)? {
  122|      0|        switch self {
  123|      0|        case .custom(_, _, _, let completion): return completion
  124|      0|        default: return nil
  125|      0|        }
  126|      0|    }
  127|       |}
  128|       |#endif

/Users/raduj/Developer/Appub/Pods/Kingfisher/Sources/ImageView+Kingfisher.swift:
    1|       |//
    2|       |//  ImageView+Kingfisher.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 15/4/6.
    6|       |//
    7|       |//  Copyright (c) 2018 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |
   28|       |#if os(macOS)
   29|       |import AppKit
   30|       |#else
   31|       |import UIKit
   32|       |#endif
   33|       |
   34|       |// MARK: - Extension methods.
   35|       |/**
   36|       | *    Set image to use from web.
   37|       | */
   38|       |extension Kingfisher where Base: ImageView {
   39|       |    /**
   40|       |     Set an image with a resource, a placeholder image, options, progress handler and completion handler.
   41|       |     
   42|       |     - parameter resource:          Resource object contains information such as `cacheKey` and `downloadURL`.
   43|       |     - parameter placeholder:       A placeholder image when retrieving the image at URL.
   44|       |     - parameter options:           A dictionary could control some behaviors. See `KingfisherOptionsInfo` for more.
   45|       |     - parameter progressBlock:     Called when the image downloading progress gets updated.
   46|       |     - parameter completionHandler: Called when the image retrieved and set.
   47|       |     
   48|       |     - returns: A task represents the retrieving process.
   49|       |     
   50|       |     - note: Both the `progressBlock` and `completionHandler` will be invoked in main thread.
   51|       |     The `CallbackDispatchQueue` specified in `optionsInfo` will not be used in callbacks of this method.
   52|       |     
   53|       |     If `resource` is `nil`, the `placeholder` image will be set and
   54|       |     `completionHandler` will be called with both `error` and `image` being `nil`.
   55|       |     */
   56|       |    @discardableResult
   57|       |    public func setImage(with resource: Resource?,
   58|       |                         placeholder: Placeholder? = nil,
   59|       |                         options: KingfisherOptionsInfo? = nil,
   60|       |                         progressBlock: DownloadProgressBlock? = nil,
   61|       |                         completionHandler: CompletionHandler? = nil) -> RetrieveImageTask
   62|      0|    {
   63|      0|        guard let resource = resource else {
   64|      0|            self.placeholder = placeholder
   65|      0|            setWebURL(nil)
   66|      0|            completionHandler?(nil, nil, .none, nil)
   67|      0|            return .empty
   68|      0|        }
   69|      0|        
   70|      0|        var options = KingfisherManager.shared.defaultOptions + (options ?? KingfisherEmptyOptionsInfo)
   71|      0|        let noImageOrPlaceholderSet = base.image == nil && self.placeholder == nil
   72|      0|        
   73|      0|        if !options.keepCurrentImageWhileLoading || noImageOrPlaceholderSet { // Always set placeholder while there is no image/placehoer yet.
   74|      0|            self.placeholder = placeholder
   75|      0|        }
   76|      0|
   77|      0|        let maybeIndicator = indicator
   78|      0|        maybeIndicator?.startAnimatingView()
   79|      0|        
   80|      0|        setWebURL(resource.downloadURL)
   81|      0|
   82|      0|        if base.shouldPreloadAllAnimation() {
   83|      0|            options.append(.preloadAllAnimationData)
   84|      0|        }
   85|      0|        
   86|      0|        let task = KingfisherManager.shared.retrieveImage(
   87|      0|            with: resource,
   88|      0|            options: options,
   89|      0|            progressBlock: { receivedSize, totalSize in
   90|      0|                guard resource.downloadURL == self.webURL else {
   91|      0|                    return
   92|      0|                }
   93|      0|                if let progressBlock = progressBlock {
   94|      0|                    progressBlock(receivedSize, totalSize)
   95|      0|                }
   96|      0|            },
   97|      0|            completionHandler: {[weak base] image, error, cacheType, imageURL in
   98|      0|                DispatchQueue.main.safeAsync {
   99|      0|                    maybeIndicator?.stopAnimatingView()
  100|      0|                    guard let strongBase = base, imageURL == self.webURL else {
  101|      0|                        completionHandler?(image, error, cacheType, imageURL)
  102|      0|                        return
  103|      0|                    }
  104|      0|                    
  105|      0|                    self.setImageTask(nil)
  106|      0|                    guard let image = image else {
  107|      0|                        completionHandler?(nil, error, cacheType, imageURL)
  108|      0|                        return
  109|      0|                    }
  110|      0|                    
  111|      0|                    guard let transitionItem = options.lastMatchIgnoringAssociatedValue(.transition(.none)),
  112|      0|                        case .transition(let transition) = transitionItem, ( options.forceTransition || cacheType == .none) else
  113|      0|                    {
  114|      0|                        self.placeholder = nil
  115|      0|                        strongBase.image = image
  116|      0|                        completionHandler?(image, error, cacheType, imageURL)
  117|      0|                        return
  118|      0|                    }
  119|      0|                    
  120|      0|                    #if !os(macOS)
  121|      0|                        UIView.transition(with: strongBase, duration: 0.0, options: [],
  122|      0|                                          animations: { maybeIndicator?.stopAnimatingView() },
  123|      0|                                          completion: { _ in
  124|      0|
  125|      0|                                            self.placeholder = nil
  126|      0|                                            UIView.transition(with: strongBase, duration: transition.duration,
  127|      0|                                                              options: [transition.animationOptions, .allowUserInteraction],
  128|      0|                                                              animations: {
  129|      0|                                                                // Set image property in the animation.
  130|      0|                                                                transition.animations?(strongBase, image)
  131|      0|                                                              },
  132|      0|                                                              completion: { finished in
  133|      0|                                                                transition.completion?(finished)
  134|      0|                                                                completionHandler?(image, error, cacheType, imageURL)
  135|      0|                                                              })
  136|      0|                                          })
  137|      0|                    #endif
  138|      0|                }
  139|      0|            })
  140|      0|        
  141|      0|        setImageTask(task)
  142|      0|        
  143|      0|        return task
  144|      0|    }
  145|       |    
  146|       |    /**
  147|       |     Cancel the image download task bounded to the image view if it is running.
  148|       |     Nothing will happen if the downloading has already finished.
  149|       |     */
  150|      0|    public func cancelDownloadTask() {
  151|      0|        imageTask?.cancel()
  152|      0|    }
  153|       |}
  154|       |
  155|       |// MARK: - Associated Object
  156|       |private var lastURLKey: Void?
  157|       |private var indicatorKey: Void?
  158|       |private var indicatorTypeKey: Void?
  159|       |private var placeholderKey: Void?
  160|       |private var imageTaskKey: Void?
  161|       |
  162|       |extension Kingfisher where Base: ImageView {
  163|       |    /// Get the image URL binded to this image view.
  164|       |    public var webURL: URL? {
  165|       |        return objc_getAssociatedObject(base, &lastURLKey) as? URL
  166|       |    }
  167|       |    
  168|       |    fileprivate func setWebURL(_ url: URL?) {
  169|       |        objc_setAssociatedObject(base, &lastURLKey, url, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
  170|       |    }
  171|       |    
  172|       |    /// Holds which indicator type is going to be used.
  173|       |    /// Default is .none, means no indicator will be shown.
  174|       |    public var indicatorType: IndicatorType {
  175|      0|        get {
  176|      0|            let indicator = objc_getAssociatedObject(base, &indicatorTypeKey) as? IndicatorType
  177|      0|            return indicator ?? .none
  178|      0|        }
  179|       |        
  180|      0|        set {
  181|      0|            switch newValue {
  182|      0|            case .none:
  183|      0|                indicator = nil
  184|      0|            case .activity:
  185|      0|                indicator = ActivityIndicator()
  186|      0|            case .image(let data):
  187|      0|                indicator = ImageIndicator(imageData: data)
  188|      0|            case .custom(let anIndicator):
  189|      0|                indicator = anIndicator
  190|      0|            }
  191|      0|            
  192|      0|            objc_setAssociatedObject(base, &indicatorTypeKey, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
  193|      0|        }
  194|       |    }
  195|       |    
  196|       |    /// Holds any type that conforms to the protocol `Indicator`.
  197|       |    /// The protocol `Indicator` has a `view` property that will be shown when loading an image.
  198|       |    /// It will be `nil` if `indicatorType` is `.none`.
  199|       |    public fileprivate(set) var indicator: Indicator? {
  200|       |        get {
  201|       |            guard let box = objc_getAssociatedObject(base, &indicatorKey) as? Box<Indicator> else {
  202|       |                return nil
  203|       |            }
  204|       |            return box.value
  205|       |        }
  206|       |        
  207|       |        set {
  208|       |            // Remove previous
  209|       |            if let previousIndicator = indicator {
  210|       |                previousIndicator.view.removeFromSuperview()
  211|       |            }
  212|       |            
  213|       |            // Add new
  214|       |            if var newIndicator = newValue {
  215|       |                // Set default indicator frame if the view's frame not set.
  216|       |                if newIndicator.view.frame == .zero {
  217|       |                    newIndicator.view.frame = base.frame
  218|       |                }
  219|       |                newIndicator.viewCenter = CGPoint(x: base.bounds.midX, y: base.bounds.midY)
  220|       |                newIndicator.view.isHidden = true
  221|       |                base.addSubview(newIndicator.view)
  222|       |            }
  223|       |            
  224|       |            // Save in associated object
  225|       |            // Wrap newValue with Box to workaround an issue that Swift does not recognize
  226|       |            // and casting protocol for associate object correctly. https://github.com/onevcat/Kingfisher/issues/872
  227|       |            objc_setAssociatedObject(base, &indicatorKey, newValue.map(Box.init), .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
  228|       |        }
  229|       |    }
  230|       |    
  231|       |    fileprivate var imageTask: RetrieveImageTask? {
  232|       |        return objc_getAssociatedObject(base, &imageTaskKey) as? RetrieveImageTask
  233|       |    }
  234|       |    
  235|       |    fileprivate func setImageTask(_ task: RetrieveImageTask?) {
  236|       |        objc_setAssociatedObject(base, &imageTaskKey, task, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
  237|       |    }
  238|       |    
  239|       |    public fileprivate(set) var placeholder: Placeholder? {
  240|       |        get {
  241|       |            return objc_getAssociatedObject(base, &placeholderKey) as? Placeholder
  242|       |        }
  243|       |        
  244|       |        set {
  245|       |            if let previousPlaceholder = placeholder {
  246|       |                previousPlaceholder.remove(from: base)
  247|       |            }
  248|       |            
  249|       |            if let newPlaceholder = newValue {
  250|       |                newPlaceholder.add(to: base)
  251|       |            } else {
  252|       |                base.image = nil
  253|       |            }
  254|       |            
  255|       |            objc_setAssociatedObject(base, &placeholderKey, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
  256|       |        }
  257|       |    }
  258|       |}
  259|       |
  260|       |
  261|       |@objc extension ImageView {
  262|      0|    func shouldPreloadAllAnimation() -> Bool { return true }
  263|       |}

/Users/raduj/Developer/Appub/Pods/Kingfisher/Sources/Indicator.swift:
    1|       |//
    2|       |//  Indicator.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by João D. Moreira on 30/08/16.
    6|       |//
    7|       |//  Copyright (c) 2018 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |#if os(macOS)
   28|       |    import AppKit
   29|       |#else
   30|       |    import UIKit
   31|       |#endif
   32|       |
   33|       |#if os(macOS)
   34|       |    public typealias IndicatorView = NSView
   35|       |#else
   36|       |    public typealias IndicatorView = UIView
   37|       |#endif
   38|       |
   39|       |public enum IndicatorType {
   40|       |    /// No indicator.
   41|       |    case none
   42|       |    /// Use system activity indicator.
   43|       |    case activity
   44|       |    /// Use an image as indicator. GIF is supported.
   45|       |    case image(imageData: Data)
   46|       |    /// Use a custom indicator, which conforms to the `Indicator` protocol.
   47|       |    case custom(indicator: Indicator)
   48|       |}
   49|       |
   50|       |// MARK: - Indicator Protocol
   51|       |public protocol Indicator {
   52|       |    func startAnimatingView()
   53|       |    func stopAnimatingView()
   54|       |
   55|       |    var viewCenter: CGPoint { get set }
   56|       |    var view: IndicatorView { get }
   57|       |}
   58|       |
   59|       |extension Indicator {
   60|       |    #if os(macOS)
   61|       |    public var viewCenter: CGPoint {
   62|       |        get {
   63|       |            let frame = view.frame
   64|       |            return CGPoint(x: frame.origin.x + frame.size.width / 2.0, y: frame.origin.y + frame.size.height / 2.0 )
   65|       |        }
   66|       |        set {
   67|       |            let frame = view.frame
   68|       |            let newFrame = CGRect(x: newValue.x - frame.size.width / 2.0,
   69|       |                                  y: newValue.y - frame.size.height / 2.0,
   70|       |                                  width: frame.size.width,
   71|       |                                  height: frame.size.height)
   72|       |            view.frame = newFrame
   73|       |        }
   74|       |    }
   75|       |    #else
   76|       |    public var viewCenter: CGPoint {
   77|      0|        get {
   78|      0|            return view.center
   79|      0|        }
   80|      0|        set {
   81|      0|            view.center = newValue
   82|      0|        }
   83|       |    }
   84|       |    #endif
   85|       |}
   86|       |
   87|       |// MARK: - ActivityIndicator
   88|       |// Displays a NSProgressIndicator / UIActivityIndicatorView
   89|       |final class ActivityIndicator: Indicator {
   90|       |
   91|       |    #if os(macOS)
   92|       |    private let activityIndicatorView: NSProgressIndicator
   93|       |    #else
   94|       |    private let activityIndicatorView: UIActivityIndicatorView
   95|       |    #endif
   96|       |    private var animatingCount = 0
   97|       |
   98|      0|    var view: IndicatorView {
   99|      0|        return activityIndicatorView
  100|      0|    }
  101|       |
  102|      0|    func startAnimatingView() {
  103|      0|        animatingCount += 1
  104|      0|        // Already animating
  105|      0|        if animatingCount == 1 {
  106|      0|            #if os(macOS)
  107|      0|                activityIndicatorView.startAnimation(nil)
  108|      0|            #else
  109|      0|                activityIndicatorView.startAnimating()
  110|      0|            #endif
  111|      0|            activityIndicatorView.isHidden = false
  112|      0|        }
  113|      0|    }
  114|       |
  115|      0|    func stopAnimatingView() {
  116|      0|        animatingCount = max(animatingCount - 1, 0)
  117|      0|        if animatingCount == 0 {
  118|      0|            #if os(macOS)
  119|      0|                activityIndicatorView.stopAnimation(nil)
  120|      0|            #else
  121|      0|                activityIndicatorView.stopAnimating()
  122|      0|            #endif
  123|      0|            activityIndicatorView.isHidden = true
  124|      0|        }
  125|      0|    }
  126|       |
  127|      0|    init() {
  128|      0|        #if os(macOS)
  129|      0|            activityIndicatorView = NSProgressIndicator(frame: CGRect(x: 0, y: 0, width: 16, height: 16))
  130|      0|            activityIndicatorView.controlSize = .small
  131|      0|            activityIndicatorView.style = .spinning
  132|      0|        #else
  133|      0|            #if os(tvOS)
  134|      0|                let indicatorStyle = UIActivityIndicatorViewStyle.white
  135|      0|            #else
  136|      0|                let indicatorStyle = UIActivityIndicatorViewStyle.gray
  137|      0|            #endif
  138|      0|            activityIndicatorView = UIActivityIndicatorView(activityIndicatorStyle:indicatorStyle)
  139|      0|            activityIndicatorView.autoresizingMask = [.flexibleLeftMargin, .flexibleRightMargin, .flexibleBottomMargin, .flexibleTopMargin]
  140|      0|        #endif
  141|      0|    }
  142|       |}
  143|       |
  144|       |// MARK: - ImageIndicator
  145|       |// Displays an ImageView. Supports gif
  146|       |final class ImageIndicator: Indicator {
  147|       |    private let animatedImageIndicatorView: ImageView
  148|       |
  149|      0|    var view: IndicatorView {
  150|      0|        return animatedImageIndicatorView
  151|      0|    }
  152|       |
  153|      0|    init?(imageData data: Data, processor: ImageProcessor = DefaultImageProcessor.default, options: KingfisherOptionsInfo = KingfisherEmptyOptionsInfo) {
  154|      0|
  155|      0|        var options = options
  156|      0|        // Use normal image view to show animations, so we need to preload all animation data.
  157|      0|        if !options.preloadAllAnimationData {
  158|      0|            options.append(.preloadAllAnimationData)
  159|      0|        }
  160|      0|        
  161|      0|        guard let image = processor.process(item: .data(data), options: options) else {
  162|      0|            return nil
  163|      0|        }
  164|      0|
  165|      0|        animatedImageIndicatorView = ImageView()
  166|      0|        animatedImageIndicatorView.image = image
  167|      0|        animatedImageIndicatorView.frame = CGRect(x: 0, y: 0, width: image.size.width, height: image.size.height)
  168|      0|        
  169|      0|        #if os(macOS)
  170|      0|            // Need for gif to animate on macOS
  171|      0|            self.animatedImageIndicatorView.imageScaling = .scaleNone
  172|      0|            self.animatedImageIndicatorView.canDrawSubviewsIntoLayer = true
  173|      0|        #else
  174|      0|            animatedImageIndicatorView.contentMode = .center
  175|      0|            animatedImageIndicatorView.autoresizingMask = [.flexibleLeftMargin,
  176|      0|                                                           .flexibleRightMargin,
  177|      0|                                                           .flexibleBottomMargin,
  178|      0|                                                           .flexibleTopMargin]
  179|      0|        #endif
  180|      0|    }
  181|       |
  182|      0|    func startAnimatingView() {
  183|      0|        #if os(macOS)
  184|      0|            animatedImageIndicatorView.animates = true
  185|      0|        #else
  186|      0|            animatedImageIndicatorView.startAnimating()
  187|      0|        #endif
  188|      0|        animatedImageIndicatorView.isHidden = false
  189|      0|    }
  190|       |
  191|      0|    func stopAnimatingView() {
  192|      0|        #if os(macOS)
  193|      0|            animatedImageIndicatorView.animates = false
  194|      0|        #else
  195|      0|            animatedImageIndicatorView.stopAnimating()
  196|      0|        #endif
  197|      0|        animatedImageIndicatorView.isHidden = true
  198|      0|    }
  199|       |}

/Users/raduj/Developer/Appub/Pods/Kingfisher/Sources/Kingfisher.swift:
    1|       |//
    2|       |//  Kingfisher.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 16/9/14.
    6|       |//
    7|       |//  Copyright (c) 2018 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import Foundation
   28|       |import ImageIO
   29|       |
   30|       |#if os(macOS)
   31|       |    import AppKit
   32|       |    public typealias Image = NSImage
   33|       |    public typealias View = NSView
   34|       |    public typealias Color = NSColor
   35|       |    public typealias ImageView = NSImageView
   36|       |    public typealias Button = NSButton
   37|       |#else
   38|       |    import UIKit
   39|       |    public typealias Image = UIImage
   40|       |    public typealias Color = UIColor
   41|       |    #if !os(watchOS)
   42|       |    public typealias ImageView = UIImageView
   43|       |    public typealias View = UIView
   44|       |    public typealias Button = UIButton
   45|       |    #else
   46|       |    import WatchKit
   47|       |    #endif
   48|       |#endif
   49|       |
   50|       |public final class Kingfisher<Base> {
   51|       |    public let base: Base
   52|      0|    public init(_ base: Base) {
   53|      0|        self.base = base
   54|      0|    }
   55|       |}
   56|       |
   57|       |/**
   58|       | A type that has Kingfisher extensions.
   59|       | */
   60|       |public protocol KingfisherCompatible {
   61|       |    associatedtype CompatibleType
   62|       |    var kf: CompatibleType { get }
   63|       |}
   64|       |
   65|       |public extension KingfisherCompatible {
   66|      0|    public var kf: Kingfisher<Self> {
   67|      0|        return Kingfisher(self)
   68|      0|    }
   69|       |}
   70|       |
   71|       |extension Image: KingfisherCompatible { }
   72|       |#if !os(watchOS)
   73|       |extension ImageView: KingfisherCompatible { }
   74|       |extension Button: KingfisherCompatible { }
   75|       |#else
   76|       |extension WKInterfaceImage: KingfisherCompatible { }
   77|       |#endif

/Users/raduj/Developer/Appub/Pods/Kingfisher/Sources/KingfisherManager.swift:
    1|       |//
    2|       |//  KingfisherManager.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 15/4/6.
    6|       |//
    7|       |//  Copyright (c) 2018 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |#if os(macOS)
   28|       |import AppKit
   29|       |#else
   30|       |import UIKit
   31|       |#endif
   32|       |
   33|       |public typealias DownloadProgressBlock = ((_ receivedSize: Int64, _ totalSize: Int64) -> Void)
   34|       |public typealias CompletionHandler = ((_ image: Image?, _ error: NSError?, _ cacheType: CacheType, _ imageURL: URL?) -> Void)
   35|       |
   36|       |/// RetrieveImageTask represents a task of image retrieving process.
   37|       |/// It contains an async task of getting image from disk and from network.
   38|       |public final class RetrieveImageTask {
   39|       |    
   40|       |    public static let empty = RetrieveImageTask()
   41|       |    
   42|       |    // If task is canceled before the download task started (which means the `downloadTask` is nil),
   43|       |    // the download task should not begin.
   44|       |    var cancelledBeforeDownloadStarting: Bool = false
   45|       |    
   46|       |    /// The network retrieve task in this image task.
   47|       |    public var downloadTask: RetrieveImageDownloadTask?
   48|       |    
   49|       |    /**
   50|       |    Cancel current task. If this task is already done, do nothing.
   51|       |    */
   52|      0|    public func cancel() {
   53|      0|        if let downloadTask = downloadTask {
   54|      0|            downloadTask.cancel()
   55|      0|        } else {
   56|      0|            cancelledBeforeDownloadStarting = true
   57|      0|        }
   58|      0|    }
   59|       |}
   60|       |
   61|       |/// Error domain of Kingfisher
   62|       |public let KingfisherErrorDomain = "com.onevcat.Kingfisher.Error"
   63|       |
   64|       |/// Main manager class of Kingfisher. It connects Kingfisher downloader and cache.
   65|       |/// You can use this class to retrieve an image via a specified URL from web or cache.
   66|       |public class KingfisherManager {
   67|       |    
   68|       |    /// Shared manager used by the extensions across Kingfisher.
   69|       |    public static let shared = KingfisherManager()
   70|       |    
   71|       |    /// Cache used by this manager
   72|       |    public var cache: ImageCache
   73|       |    
   74|       |    /// Downloader used by this manager
   75|       |    public var downloader: ImageDownloader
   76|       |    
   77|       |    /// Default options used by the manager. This option will be used in 
   78|       |    /// Kingfisher manager related methods, including all image view and 
   79|       |    /// button extension methods. You can also passing the options per image by 
   80|       |    /// sending an `options` parameter to Kingfisher's APIs, the per image option 
   81|       |    /// will overwrite the default ones if exist.
   82|       |    ///
   83|       |    /// - Note: This option will not be applied to independent using of `ImageDownloader` or `ImageCache`.
   84|       |    public var defaultOptions = KingfisherEmptyOptionsInfo
   85|       |    
   86|      0|    var currentDefaultOptions: KingfisherOptionsInfo {
   87|      0|        return [.downloader(downloader), .targetCache(cache)] + defaultOptions
   88|      0|    }
   89|       |    
   90|      0|    convenience init() {
   91|      0|        self.init(downloader: .default, cache: .default)
   92|      0|    }
   93|       |    
   94|      0|    init(downloader: ImageDownloader, cache: ImageCache) {
   95|      0|        self.downloader = downloader
   96|      0|        self.cache = cache
   97|      0|    }
   98|       |    
   99|       |    /**
  100|       |    Get an image with resource.
  101|       |    If KingfisherOptions.None is used as `options`, Kingfisher will seek the image in memory and disk first.
  102|       |    If not found, it will download the image at `resource.downloadURL` and cache it with `resource.cacheKey`.
  103|       |    These default behaviors could be adjusted by passing different options. See `KingfisherOptions` for more.
  104|       |    
  105|       |    - parameter resource:          Resource object contains information such as `cacheKey` and `downloadURL`.
  106|       |    - parameter options:           A dictionary could control some behaviors. See `KingfisherOptionsInfo` for more.
  107|       |    - parameter progressBlock:     Called every time downloaded data changed. This could be used as a progress UI.
  108|       |    - parameter completionHandler: Called when the whole retrieving process finished.
  109|       |    
  110|       |    - returns: A `RetrieveImageTask` task object. You can use this object to cancel the task.
  111|       |    */
  112|       |    @discardableResult
  113|       |    public func retrieveImage(with resource: Resource,
  114|       |        options: KingfisherOptionsInfo?,
  115|       |        progressBlock: DownloadProgressBlock?,
  116|       |        completionHandler: CompletionHandler?) -> RetrieveImageTask
  117|      0|    {
  118|      0|        let task = RetrieveImageTask()
  119|      0|        let options = currentDefaultOptions + (options ?? KingfisherEmptyOptionsInfo)
  120|      0|        if options.forceRefresh {
  121|      0|            _ = downloadAndCacheImage(
  122|      0|                with: resource.downloadURL,
  123|      0|                forKey: resource.cacheKey,
  124|      0|                retrieveImageTask: task,
  125|      0|                progressBlock: progressBlock,
  126|      0|                completionHandler: completionHandler,
  127|      0|                options: options)
  128|      0|        } else {
  129|      0|            tryToRetrieveImageFromCache(
  130|      0|                forKey: resource.cacheKey,
  131|      0|                with: resource.downloadURL,
  132|      0|                retrieveImageTask: task,
  133|      0|                progressBlock: progressBlock,
  134|      0|                completionHandler: completionHandler,
  135|      0|                options: options)
  136|      0|        }
  137|      0|        
  138|      0|        return task
  139|      0|    }
  140|       |
  141|       |    @discardableResult
  142|       |    func downloadAndCacheImage(with url: URL,
  143|       |                             forKey key: String,
  144|       |                      retrieveImageTask: RetrieveImageTask,
  145|       |                          progressBlock: DownloadProgressBlock?,
  146|       |                      completionHandler: CompletionHandler?,
  147|       |                                options: KingfisherOptionsInfo) -> RetrieveImageDownloadTask?
  148|      0|    {
  149|      0|        let downloader = options.downloader
  150|      0|        return downloader.downloadImage(with: url, retrieveImageTask: retrieveImageTask, options: options,
  151|      0|            progressBlock: { receivedSize, totalSize in
  152|      0|                progressBlock?(receivedSize, totalSize)
  153|      0|            },
  154|      0|            completionHandler: { image, error, imageURL, originalData in
  155|      0|
  156|      0|                let targetCache = options.targetCache
  157|      0|                if let error = error, error.code == KingfisherError.notModified.rawValue {
  158|      0|                    // Not modified. Try to find the image from cache.
  159|      0|                    // (The image should be in cache. It should be guaranteed by the framework users.)
  160|      0|                    targetCache.retrieveImage(forKey: key, options: options, completionHandler: { (cacheImage, cacheType) -> Void in
  161|      0|                        completionHandler?(cacheImage, nil, cacheType, url)
  162|      0|                    })
  163|      0|                    return
  164|      0|                }
  165|      0|                
  166|      0|                if let image = image, let originalData = originalData {
  167|      0|                    targetCache.store(image,
  168|      0|                                      original: originalData,
  169|      0|                                      forKey: key,
  170|      0|                                      processorIdentifier:options.processor.identifier,
  171|      0|                                      cacheSerializer: options.cacheSerializer,
  172|      0|                                      toDisk: !options.cacheMemoryOnly,
  173|      0|                                      completionHandler: nil)
  174|      0|                    if options.cacheOriginalImage && options.processor != DefaultImageProcessor.default {
  175|      0|                        let originalCache = options.originalCache
  176|      0|                        let defaultProcessor = DefaultImageProcessor.default
  177|      0|                        if let originalImage = defaultProcessor.process(item: .data(originalData), options: options) {
  178|      0|                            originalCache.store(originalImage,
  179|      0|                                              original: originalData,
  180|      0|                                              forKey: key,
  181|      0|                                              processorIdentifier: defaultProcessor.identifier,
  182|      0|                                              cacheSerializer: options.cacheSerializer,
  183|      0|                                              toDisk: !options.cacheMemoryOnly,
  184|      0|                                              completionHandler: nil)
  185|      0|                        }
  186|      0|                    }
  187|      0|                }
  188|      0|
  189|      0|                completionHandler?(image, error, .none, url)
  190|      0|
  191|      0|            })
  192|      0|    }
  193|       |    
  194|       |    func tryToRetrieveImageFromCache(forKey key: String,
  195|       |                                       with url: URL,
  196|       |                              retrieveImageTask: RetrieveImageTask,
  197|       |                                  progressBlock: DownloadProgressBlock?,
  198|       |                              completionHandler: CompletionHandler?,
  199|       |                                        options: KingfisherOptionsInfo)
  200|      0|    {
  201|      0|
  202|      0|        let diskTaskCompletionHandler: CompletionHandler = { (image, error, cacheType, imageURL) -> Void in
  203|      0|            completionHandler?(image, error, cacheType, imageURL)
  204|      0|        }
  205|      0|        
  206|      0|        func handleNoCache() {
  207|      0|            if options.onlyFromCache {
  208|      0|                let error = NSError(domain: KingfisherErrorDomain, code: KingfisherError.notCached.rawValue, userInfo: nil)
  209|      0|                diskTaskCompletionHandler(nil, error, .none, url)
  210|      0|                return
  211|      0|            }
  212|      0|            self.downloadAndCacheImage(
  213|      0|                with: url,
  214|      0|                forKey: key,
  215|      0|                retrieveImageTask: retrieveImageTask,
  216|      0|                progressBlock: progressBlock,
  217|      0|                completionHandler: diskTaskCompletionHandler,
  218|      0|                options: options)
  219|      0|            
  220|      0|        }
  221|      0|        
  222|      0|        let targetCache = options.targetCache
  223|      0|        // First, try to get the exactly image from cache
  224|      0|        targetCache.retrieveImage(forKey: key, options: options) { image, cacheType in
  225|      0|            // If found, we could finish now.
  226|      0|            if image != nil {
  227|      0|                diskTaskCompletionHandler(image, nil, cacheType, url)
  228|      0|                return
  229|      0|            }
  230|      0|            
  231|      0|            // If not found, and we are using a default processor, download it!
  232|      0|            let processor = options.processor
  233|      0|            guard processor != DefaultImageProcessor.default else {
  234|      0|                handleNoCache()
  235|      0|                return
  236|      0|            }
  237|      0|            
  238|      0|            // If processor is not the default one, we have a chance to check whether
  239|      0|            // the original image is already in cache.
  240|      0|            let originalCache = options.originalCache
  241|      0|            let optionsWithoutProcessor = options.removeAllMatchesIgnoringAssociatedValue(.processor(processor))
  242|      0|            originalCache.retrieveImage(forKey: key, options: optionsWithoutProcessor) { image, cacheType in
  243|      0|                // If we found the original image, there is no need to download it again.
  244|      0|                // We could just apply processor to it now.
  245|      0|                guard let image = image else {
  246|      0|                    handleNoCache()
  247|      0|                    return
  248|      0|                }
  249|      0|                
  250|      0|                guard let processedImage = processor.process(item: .image(image), options: options) else {
  251|      0|                    diskTaskCompletionHandler(nil, nil, .none, url)
  252|      0|                    return
  253|      0|                }
  254|      0|                targetCache.store(processedImage,
  255|      0|                                  original: nil,
  256|      0|                                  forKey: key,
  257|      0|                                  processorIdentifier:options.processor.identifier,
  258|      0|                                  cacheSerializer: options.cacheSerializer,
  259|      0|                                  toDisk: !options.cacheMemoryOnly,
  260|      0|                                  completionHandler: nil)
  261|      0|                diskTaskCompletionHandler(processedImage, nil, .none, url)
  262|      0|            }
  263|      0|        }
  264|      0|    }
  265|       |}

/Users/raduj/Developer/Appub/Pods/Kingfisher/Sources/KingfisherOptionsInfo.swift:
    1|       |//
    2|       |//  KingfisherOptionsInfo.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 15/4/23.
    6|       |//
    7|       |//  Copyright (c) 2018 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |#if os(macOS)
   28|       |import AppKit
   29|       |#else
   30|       |import UIKit
   31|       |#endif
   32|       |    
   33|       |
   34|       |/**
   35|       |*	KingfisherOptionsInfo is a typealias for [KingfisherOptionsInfoItem]. You can use the enum of option item with value to control some behaviors of Kingfisher.
   36|       |*/
   37|       |public typealias KingfisherOptionsInfo = [KingfisherOptionsInfoItem]
   38|       |let KingfisherEmptyOptionsInfo = [KingfisherOptionsInfoItem]()
   39|       |
   40|       |/**
   41|       |Items could be added into KingfisherOptionsInfo.
   42|       |*/
   43|       |public enum KingfisherOptionsInfoItem {
   44|       |    /// The associated value of this member should be an ImageCache object. Kingfisher will use the specified
   45|       |    /// cache object when handling related operations, including trying to retrieve the cached images and store
   46|       |    /// the downloaded image to it.
   47|       |    case targetCache(ImageCache)
   48|       |    
   49|       |    /// Cache for storing and retrieving original image.
   50|       |    /// Preferred prior to targetCache for storing and retrieving original images if specified.
   51|       |    /// Only used if a non-default image processor is involved.
   52|       |    case originalCache(ImageCache)
   53|       |    
   54|       |    /// The associated value of this member should be an ImageDownloader object. Kingfisher will use this
   55|       |    /// downloader to download the images.
   56|       |    case downloader(ImageDownloader)
   57|       |    
   58|       |    /// Member for animation transition when using UIImageView. Kingfisher will use the `ImageTransition` of
   59|       |    /// this enum to animate the image in if it is downloaded from web. The transition will not happen when the
   60|       |    /// image is retrieved from either memory or disk cache by default. If you need to do the transition even when
   61|       |    /// the image being retrieved from cache, set `ForceTransition` as well.
   62|       |    case transition(ImageTransition)
   63|       |    
   64|       |    /// Associated `Float` value will be set as the priority of image download task. The value for it should be
   65|       |    /// between 0.0~1.0. If this option not set, the default value (`NSURLSessionTaskPriorityDefault`) will be used.
   66|       |    case downloadPriority(Float)
   67|       |    
   68|       |    /// If set, `Kingfisher` will ignore the cache and try to fire a download task for the resource.
   69|       |    case forceRefresh
   70|       |
   71|       |    /// If set, `Kingfisher` will try to retrieve the image from memory cache first. If the image is not in memory
   72|       |    /// cache, then it will ignore the disk cache but download the image again from network. This is useful when
   73|       |    /// you want to display a changeable image behind the same url, while avoiding download it again and again.
   74|       |    case fromMemoryCacheOrRefresh
   75|       |    
   76|       |    /// If set, setting the image to an image view will happen with transition even when retrieved from cache.
   77|       |    /// See `Transition` option for more.
   78|       |    case forceTransition
   79|       |    
   80|       |    ///  If set, `Kingfisher` will only cache the value in memory but not in disk.
   81|       |    case cacheMemoryOnly
   82|       |    
   83|       |    /// If set, `Kingfisher` will only try to retrieve the image from cache not from network.
   84|       |    case onlyFromCache
   85|       |    
   86|       |    /// Decode the image in background thread before using.
   87|       |    case backgroundDecode
   88|       |    
   89|       |    /// The associated value of this member will be used as the target queue of dispatch callbacks when
   90|       |    /// retrieving images from cache. If not set, `Kingfisher` will use main queue for callbacks.
   91|       |    case callbackDispatchQueue(DispatchQueue?)
   92|       |    
   93|       |    /// The associated value of this member will be used as the scale factor when converting retrieved data to an image.
   94|       |    /// It is the image scale, instead of your screen scale. You may need to specify the correct scale when you dealing 
   95|       |    /// with 2x or 3x retina images.
   96|       |    case scaleFactor(CGFloat)
   97|       |
   98|       |    /// Whether all the animated image data should be preloaded. Default it false, which means following frames will be
   99|       |    /// loaded on need. If true, all the animated image data will be loaded and decoded into memory. This option is mainly
  100|       |    /// used for back compatibility internally. You should not set it directly. `AnimatedImageView` will not preload
  101|       |    /// all data, while a normal image view (`UIImageView` or `NSImageView`) will load all data. Choose to use
  102|       |    /// corresponding image view type instead of setting this option.
  103|       |    case preloadAllAnimationData
  104|       |    
  105|       |    /// The `ImageDownloadRequestModifier` contained will be used to change the request before it being sent.
  106|       |    /// This is the last chance you can modify the request. You can modify the request for some customizing purpose,
  107|       |    /// such as adding auth token to the header, do basic HTTP auth or something like url mapping. The original request
  108|       |    /// will be sent without any modification by default.
  109|       |    case requestModifier(ImageDownloadRequestModifier)
  110|       |    
  111|       |    /// Processor for processing when the downloading finishes, a processor will convert the downloaded data to an image
  112|       |    /// and/or apply some filter on it. If a cache is connected to the downloader (it happens when you are using
  113|       |    /// KingfisherManager or the image extension methods), the converted image will also be sent to cache as well as the
  114|       |    /// image view. `DefaultImageProcessor.default` will be used by default.
  115|       |    case processor(ImageProcessor)
  116|       |    
  117|       |    /// Supply an `CacheSerializer` to convert some data to an image object for
  118|       |    /// retrieving from disk cache or vice versa for storing to disk cache.
  119|       |    /// `DefaultCacheSerializer.default` will be used by default.
  120|       |    case cacheSerializer(CacheSerializer)
  121|       |
  122|       |    /// Modifier for modifying an image right before it is used.
  123|       |    /// If the image was fetched directly from the downloader, the modifier will
  124|       |    /// run directly after the processor.
  125|       |    /// If the image is being fetched from a cache, the modifier will run after
  126|       |    /// the cacheSerializer.
  127|       |    /// Use `ImageModifier` when you need to set properties on a concrete type
  128|       |    /// of `Image`, such as a `UIImage`, that do not persist when caching the image.
  129|       |    case imageModifier(ImageModifier)
  130|       |    
  131|       |    /// Keep the existing image while setting another image to an image view.
  132|       |    /// By setting this option, the placeholder image parameter of imageview extension method
  133|       |    /// will be ignored and the current image will be kept while loading or downloading the new image.
  134|       |    case keepCurrentImageWhileLoading
  135|       |    
  136|       |    /// If set, Kingfisher will only load the first frame from a animated image data file as a single image.
  137|       |    /// Loading a lot of animated images may take too much memory. It will be useful when you want to display a
  138|       |    /// static preview of the first frame from a animated image.
  139|       |    /// This option will be ignored if the target image is not animated image data.
  140|       |    case onlyLoadFirstFrame
  141|       |    
  142|       |    /// If set and an `ImageProcessor` is used, Kingfisher will try to cache both 
  143|       |    /// the final result and original image. Kingfisher will have a chance to use 
  144|       |    /// the original image when another processor is applied to the same resource,
  145|       |    /// instead of downloading it again.
  146|       |    case cacheOriginalImage
  147|       |}
  148|       |
  149|       |precedencegroup ItemComparisonPrecedence {
  150|       |    associativity: none
  151|       |    higherThan: LogicalConjunctionPrecedence
  152|       |}
  153|       |
  154|       |infix operator <== : ItemComparisonPrecedence
  155|       |
  156|       |// This operator returns true if two `KingfisherOptionsInfoItem` enum is the same, without considering the associated values.
  157|      0|func <== (lhs: KingfisherOptionsInfoItem, rhs: KingfisherOptionsInfoItem) -> Bool {
  158|      0|    switch (lhs, rhs) {
  159|      0|    case (.targetCache(_), .targetCache(_)): return true
  160|      0|    case (.originalCache(_), .originalCache(_)): return true
  161|      0|    case (.downloader(_), .downloader(_)): return true
  162|      0|    case (.transition(_), .transition(_)): return true
  163|      0|    case (.downloadPriority(_), .downloadPriority(_)): return true
  164|      0|    case (.forceRefresh, .forceRefresh): return true
  165|      0|    case (.fromMemoryCacheOrRefresh, .fromMemoryCacheOrRefresh): return true
  166|      0|    case (.forceTransition, .forceTransition): return true
  167|      0|    case (.cacheMemoryOnly, .cacheMemoryOnly): return true
  168|      0|    case (.onlyFromCache, .onlyFromCache): return true
  169|      0|    case (.backgroundDecode, .backgroundDecode): return true
  170|      0|    case (.callbackDispatchQueue(_), .callbackDispatchQueue(_)): return true
  171|      0|    case (.scaleFactor(_), .scaleFactor(_)): return true
  172|      0|    case (.preloadAllAnimationData, .preloadAllAnimationData): return true
  173|      0|    case (.requestModifier(_), .requestModifier(_)): return true
  174|      0|    case (.processor(_), .processor(_)): return true
  175|      0|    case (.cacheSerializer(_), .cacheSerializer(_)): return true
  176|      0|    case (.imageModifier(_), .imageModifier(_)): return true
  177|      0|    case (.keepCurrentImageWhileLoading, .keepCurrentImageWhileLoading): return true
  178|      0|    case (.onlyLoadFirstFrame, .onlyLoadFirstFrame): return true
  179|      0|    case (.cacheOriginalImage, .cacheOriginalImage): return true
  180|      0|    default: return false
  181|      0|    }
  182|      0|}
  183|       |
  184|       |
  185|       |extension Collection where Iterator.Element == KingfisherOptionsInfoItem {
  186|      0|    func lastMatchIgnoringAssociatedValue(_ target: Iterator.Element) -> Iterator.Element? {
  187|      0|        return reversed().first { $0 <== target }
  188|      0|    }
  189|       |    
  190|      0|    func removeAllMatchesIgnoringAssociatedValue(_ target: Iterator.Element) -> [Iterator.Element] {
  191|      0|        return filter { !($0 <== target) }
  192|      0|    }
  193|       |}
  194|       |
  195|       |public extension Collection where Iterator.Element == KingfisherOptionsInfoItem {
  196|       |    /// The target `ImageCache` which is used.
  197|      0|    public var targetCache: ImageCache {
  198|      0|        if let item = lastMatchIgnoringAssociatedValue(.targetCache(.default)),
  199|      0|            case .targetCache(let cache) = item
  200|      0|        {
  201|      0|            return cache
  202|      0|        }
  203|      0|        return ImageCache.default
  204|      0|    }
  205|       |    
  206|       |    /// The original `ImageCache` which is used.
  207|      0|    public var originalCache: ImageCache {
  208|      0|        if let item = lastMatchIgnoringAssociatedValue(.originalCache(.default)),
  209|      0|            case .originalCache(let cache) = item
  210|      0|        {
  211|      0|            return cache
  212|      0|        }
  213|      0|        return targetCache
  214|      0|    }
  215|       |    
  216|       |    /// The `ImageDownloader` which is specified.
  217|      0|    public var downloader: ImageDownloader {
  218|      0|        if let item = lastMatchIgnoringAssociatedValue(.downloader(.default)),
  219|      0|            case .downloader(let downloader) = item
  220|      0|        {
  221|      0|            return downloader
  222|      0|        }
  223|      0|        return ImageDownloader.default
  224|      0|    }
  225|       |    
  226|       |    /// Member for animation transition when using UIImageView.
  227|      0|    public var transition: ImageTransition {
  228|      0|        if let item = lastMatchIgnoringAssociatedValue(.transition(.none)),
  229|      0|            case .transition(let transition) = item
  230|      0|        {
  231|      0|            return transition
  232|      0|        }
  233|      0|        return ImageTransition.none
  234|      0|    }
  235|       |    
  236|       |    /// A `Float` value set as the priority of image download task. The value for it should be
  237|       |    /// between 0.0~1.0.
  238|      0|    public var downloadPriority: Float {
  239|      0|        if let item = lastMatchIgnoringAssociatedValue(.downloadPriority(0)),
  240|      0|            case .downloadPriority(let priority) = item
  241|      0|        {
  242|      0|            return priority
  243|      0|        }
  244|      0|        return URLSessionTask.defaultPriority
  245|      0|    }
  246|       |    
  247|       |    /// Whether an image will be always downloaded again or not.
  248|      0|    public var forceRefresh: Bool {
  249|      0|        return contains{ $0 <== .forceRefresh }
  250|      0|    }
  251|       |
  252|       |    /// Whether an image should be got only from memory cache or download.
  253|      0|    public var fromMemoryCacheOrRefresh: Bool {
  254|      0|        return contains{ $0 <== .fromMemoryCacheOrRefresh }
  255|      0|    }
  256|       |    
  257|       |    /// Whether the transition should always happen or not.
  258|      0|    public var forceTransition: Bool {
  259|      0|        return contains{ $0 <== .forceTransition }
  260|      0|    }
  261|       |    
  262|       |    /// Whether cache the image only in memory or not.
  263|      0|    public var cacheMemoryOnly: Bool {
  264|      0|        return contains{ $0 <== .cacheMemoryOnly }
  265|      0|    }
  266|       |    
  267|       |    /// Whether only load the images from cache or not.
  268|      0|    public var onlyFromCache: Bool {
  269|      0|        return contains{ $0 <== .onlyFromCache }
  270|      0|    }
  271|       |    
  272|       |    /// Whether the image should be decoded in background or not.
  273|      0|    public var backgroundDecode: Bool {
  274|      0|        return contains{ $0 <== .backgroundDecode }
  275|      0|    }
  276|       |
  277|       |    /// Whether the image data should be all loaded at once if it is an animated image.
  278|      0|    public var preloadAllAnimationData: Bool {
  279|      0|        return contains { $0 <== .preloadAllAnimationData }
  280|      0|    }
  281|       |    
  282|       |    /// The queue of callbacks should happen from Kingfisher.
  283|      0|    public var callbackDispatchQueue: DispatchQueue {
  284|      0|        if let item = lastMatchIgnoringAssociatedValue(.callbackDispatchQueue(nil)),
  285|      0|            case .callbackDispatchQueue(let queue) = item
  286|      0|        {
  287|      0|            return queue ?? DispatchQueue.main
  288|      0|        }
  289|      0|        return DispatchQueue.main
  290|      0|    }
  291|       |    
  292|       |    /// The scale factor which should be used for the image.
  293|      0|    public var scaleFactor: CGFloat {
  294|      0|        if let item = lastMatchIgnoringAssociatedValue(.scaleFactor(0)),
  295|      0|            case .scaleFactor(let scale) = item
  296|      0|        {
  297|      0|            return scale
  298|      0|        }
  299|      0|        return 1.0
  300|      0|    }
  301|       |    
  302|       |    /// The `ImageDownloadRequestModifier` will be used before sending a download request.
  303|      0|    public var modifier: ImageDownloadRequestModifier {
  304|      0|        if let item = lastMatchIgnoringAssociatedValue(.requestModifier(NoModifier.default)),
  305|      0|            case .requestModifier(let modifier) = item
  306|      0|        {
  307|      0|            return modifier
  308|      0|        }
  309|      0|        return NoModifier.default
  310|      0|    }
  311|       |    
  312|       |    /// `ImageProcessor` for processing when the downloading finishes.
  313|      0|    public var processor: ImageProcessor {
  314|      0|        if let item = lastMatchIgnoringAssociatedValue(.processor(DefaultImageProcessor.default)),
  315|      0|            case .processor(let processor) = item
  316|      0|        {
  317|      0|            return processor
  318|      0|        }
  319|      0|        return DefaultImageProcessor.default
  320|      0|    }
  321|       |
  322|       |    /// `ImageModifier` for modifying right before the image is displayed.
  323|      0|    public var imageModifier: ImageModifier {
  324|      0|        if let item = lastMatchIgnoringAssociatedValue(.imageModifier(DefaultImageModifier.default)),
  325|      0|            case .imageModifier(let imageModifier) = item
  326|      0|        {
  327|      0|            return imageModifier
  328|      0|        }
  329|      0|        return DefaultImageModifier.default
  330|      0|    }
  331|       |    
  332|       |    /// `CacheSerializer` to convert image to data for storing in cache.
  333|      0|    public var cacheSerializer: CacheSerializer {
  334|      0|        if let item = lastMatchIgnoringAssociatedValue(.cacheSerializer(DefaultCacheSerializer.default)),
  335|      0|            case .cacheSerializer(let cacheSerializer) = item
  336|      0|        {
  337|      0|            return cacheSerializer
  338|      0|        }
  339|      0|        return DefaultCacheSerializer.default
  340|      0|    }
  341|       |    
  342|       |    /// Keep the existing image while setting another image to an image view. 
  343|       |    /// Or the placeholder will be used while downloading.
  344|      0|    public var keepCurrentImageWhileLoading: Bool {
  345|      0|        return contains { $0 <== .keepCurrentImageWhileLoading }
  346|      0|    }
  347|       |    
  348|      0|    public var onlyLoadFirstFrame: Bool {
  349|      0|        return contains { $0 <== .onlyLoadFirstFrame }
  350|      0|    }
  351|       |    
  352|      0|    public var cacheOriginalImage: Bool {
  353|      0|        return contains { $0 <== .cacheOriginalImage }
  354|      0|    }
  355|       |}

/Users/raduj/Developer/Appub/Pods/Kingfisher/Sources/Placeholder.swift:
    1|       |//
    2|       |//  Placeholder.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Tieme van Veen on 28/08/2017.
    6|       |//
    7|       |//  Copyright (c) 2018 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |#if os(macOS)
   28|       |    import AppKit
   29|       |#else
   30|       |    import UIKit
   31|       |#endif
   32|       |
   33|       |
   34|       |/// Represent a placeholder type which could be set while loading as well as
   35|       |/// loading finished without getting an image.
   36|       |public protocol Placeholder {
   37|       |    
   38|       |    /// How the placeholder should be added to a given image view.
   39|       |    func add(to imageView: ImageView)
   40|       |    
   41|       |    /// How the placeholder should be removed from a given image view.
   42|       |    func remove(from imageView: ImageView)
   43|       |}
   44|       |
   45|       |/// Default implementation of an image placeholder. The image will be set or 
   46|       |/// reset directly for `image` property of the image view.
   47|       |extension Placeholder where Self: Image {
   48|       |    
   49|       |    /// How the placeholder should be added to a given image view.
   50|      0|    public func add(to imageView: ImageView) { imageView.image = self }
   51|       |    
   52|       |    /// How the placeholder should be removed from a given image view.
   53|      0|    public func remove(from imageView: ImageView) { imageView.image = nil }
   54|       |}
   55|       |
   56|       |extension Image: Placeholder {}
   57|       |
   58|       |/// Default implementation of an arbitrary view as placeholder. The view will be 
   59|       |/// added as a subview when adding and be removed from its super view when removing.
   60|       |///
   61|       |/// To use your customize View type as placeholder, simply let it conforming to 
   62|       |/// `Placeholder` by `extension MyView: Placeholder {}`.
   63|       |extension Placeholder where Self: View {
   64|       |    
   65|       |    /// How the placeholder should be added to a given image view.
   66|      0|    public func add(to imageView: ImageView) {
   67|      0|        imageView.addSubview(self)
   68|      0|
   69|      0|        self.translatesAutoresizingMaskIntoConstraints = false
   70|      0|        NSLayoutConstraint.activate([
   71|      0|            NSLayoutConstraint(item: self, attribute: .centerX, relatedBy: .equal, toItem: imageView, attribute: .centerX, multiplier: 1, constant: 0),
   72|      0|            NSLayoutConstraint(item: self, attribute: .centerY, relatedBy: .equal, toItem: imageView, attribute: .centerY, multiplier: 1, constant: 0),
   73|      0|            NSLayoutConstraint(item: self, attribute: .height, relatedBy: .equal, toItem: imageView, attribute: .height, multiplier: 1, constant: 0),
   74|      0|            NSLayoutConstraint(item: self, attribute: .width, relatedBy: .equal, toItem: imageView, attribute: .width, multiplier: 1, constant: 0)
   75|      0|            ])
   76|      0|    }
   77|       |
   78|       |    /// How the placeholder should be removed from a given image view.
   79|      0|    public func remove(from imageView: ImageView) {
   80|      0|        self.removeFromSuperview()
   81|      0|    }
   82|       |}

/Users/raduj/Developer/Appub/Pods/Kingfisher/Sources/RequestModifier.swift:
    1|       |//
    2|       |//  RequestModifier.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 2016/09/05.
    6|       |//
    7|       |//  Copyright (c) 2018 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import Foundation
   28|       |
   29|       |/// Request modifier of image downloader.
   30|       |public protocol ImageDownloadRequestModifier {
   31|       |    func modified(for request: URLRequest) -> URLRequest?
   32|       |}
   33|       |
   34|       |struct NoModifier: ImageDownloadRequestModifier {
   35|       |    static let `default` = NoModifier()
   36|      0|    private init() {}
   37|      0|    func modified(for request: URLRequest) -> URLRequest? {
   38|      0|        return request
   39|      0|    }
   40|       |}
   41|       |
   42|       |public struct AnyModifier: ImageDownloadRequestModifier {
   43|       |    
   44|       |    let block: (URLRequest) -> URLRequest?
   45|       |    
   46|      0|    public func modified(for request: URLRequest) -> URLRequest? {
   47|      0|        return block(request)
   48|      0|    }
   49|       |    
   50|      0|    public init(modify: @escaping (URLRequest) -> URLRequest? ) {
   51|      0|        block = modify
   52|      0|    }
   53|       |}

/Users/raduj/Developer/Appub/Pods/Kingfisher/Sources/Resource.swift:
    1|       |//
    2|       |//  Resource.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 15/4/6.
    6|       |//
    7|       |//  Copyright (c) 2018 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import Foundation
   28|       |
   29|       |
   30|       |/// `Resource` protocol defines how to download and cache a resource from network.
   31|       |public protocol Resource {
   32|       |    /// The key used in cache.
   33|       |    var cacheKey: String { get }
   34|       |    
   35|       |    /// The target image URL.
   36|       |    var downloadURL: URL { get }
   37|       |}
   38|       |
   39|       |/**
   40|       | ImageResource is a simple combination of `downloadURL` and `cacheKey`.
   41|       | 
   42|       | When passed to image view set methods, Kingfisher will try to download the target 
   43|       | image from the `downloadURL`, and then store it with the `cacheKey` as the key in cache.
   44|       | */
   45|       |public struct ImageResource: Resource {
   46|       |    /// The key used in cache.
   47|       |    public let cacheKey: String
   48|       |    
   49|       |    /// The target image URL.
   50|       |    public let downloadURL: URL
   51|       |    
   52|       |    /**
   53|       |     Create a resource.
   54|       |     
   55|       |     - parameter downloadURL: The target image URL.
   56|       |     - parameter cacheKey:    The cache key. If `nil`, Kingfisher will use the `absoluteString` of `downloadURL` as the key.
   57|       |     
   58|       |     - returns: A resource.
   59|       |     */
   60|      0|    public init(downloadURL: URL, cacheKey: String? = nil) {
   61|      0|        self.downloadURL = downloadURL
   62|      0|        self.cacheKey = cacheKey ?? downloadURL.absoluteString
   63|      0|    }
   64|       |}
   65|       |
   66|       |/**
   67|       | URL conforms to `Resource` in Kingfisher.
   68|       | The `absoluteString` of this URL is used as `cacheKey`. And the URL itself will be used as `downloadURL`.
   69|       | If you need customize the url and/or cache key, use `ImageResource` instead.
   70|       | */
   71|       |extension URL: Resource {
   72|      0|    public var cacheKey: String { return absoluteString }
   73|      0|    public var downloadURL: URL { return self }
   74|       |}

/Users/raduj/Developer/Appub/Pods/Kingfisher/Sources/String+MD5.swift:
    1|       |//
    2|       |//  String+MD5.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |// To date, adding CommonCrypto to a Swift framework is problematic. See:
    6|       |// http://stackoverflow.com/questions/25248598/importing-commoncrypto-in-a-swift-framework
    7|       |// We're using a subset and modified version of CryptoSwift as an alternative.
    8|       |// The following is an altered source version that only includes MD5. The original software can be found at:
    9|       |// https://github.com/krzyzanowskim/CryptoSwift
   10|       |// This is the original copyright notice:
   11|       |
   12|       |/*
   13|       |Copyright (C) 2014 Marcin Krzyżanowski <marcin.krzyzanowski@gmail.com>
   14|       |This software is provided 'as-is', without any express or implied warranty.
   15|       |In no event will the authors be held liable for any damages arising from the use of this software.
   16|       |Permission is granted to anyone to use this software for any purpose,including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions:
   17|       |- The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation is required.
   18|       |- Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
   19|       |- This notice may not be removed or altered from any source or binary distribution.
   20|       |*/
   21|       |
   22|       |import Foundation
   23|       |
   24|       |public struct StringProxy {
   25|       |    fileprivate let base: String
   26|      0|    init(proxy: String) {
   27|      0|        base = proxy
   28|      0|    }
   29|       |}
   30|       |
   31|       |extension String: KingfisherCompatible {
   32|       |    public typealias CompatibleType = StringProxy
   33|      0|    public var kf: CompatibleType {
   34|      0|        return StringProxy(proxy: self)
   35|      0|    }
   36|       |}
   37|       |
   38|       |extension StringProxy {
   39|      0|    var md5: String {
   40|      0|        if let data = base.data(using: .utf8, allowLossyConversion: true) {
   41|      0|
   42|      0|            let message = data.withUnsafeBytes { bytes -> [UInt8] in
   43|      0|                return Array(UnsafeBufferPointer(start: bytes, count: data.count))
   44|      0|            }
   45|      0|
   46|      0|            let MD5Calculator = MD5(message)
   47|      0|            let MD5Data = MD5Calculator.calculate()
   48|      0|
   49|      0|            var MD5String = String()
   50|      0|            for c in MD5Data {
   51|      0|                MD5String += String(format: "%02x", c)
   52|      0|            }
   53|      0|            return MD5String
   54|      0|
   55|      0|        } else {
   56|      0|            return base
   57|      0|        }
   58|      0|    }
   59|       |}
   60|       |
   61|       |
   62|       |/** array of bytes, little-endian representation */
   63|      0|func arrayOfBytes<T>(_ value: T, length: Int? = nil) -> [UInt8] {
   64|      0|    let totalBytes = length ?? (MemoryLayout<T>.size * 8)
   65|      0|    
   66|      0|    let valuePointer = UnsafeMutablePointer<T>.allocate(capacity: 1)
   67|      0|    valuePointer.pointee = value
   68|      0|
   69|      0|    let bytes = valuePointer.withMemoryRebound(to: UInt8.self, capacity: totalBytes) { (bytesPointer) -> [UInt8] in
   70|      0|        var bytes = [UInt8](repeating: 0, count: totalBytes)
   71|      0|        for j in 0..<min(MemoryLayout<T>.size, totalBytes) {
   72|      0|            bytes[totalBytes - 1 - j] = (bytesPointer + j).pointee
   73|      0|        }
   74|      0|        return bytes
   75|      0|    }
   76|      0|
   77|      0|    #if swift(>=4.1)
   78|      0|    valuePointer.deinitialize(count: 1)
   79|      0|    valuePointer.deallocate()
   80|      0|    #else
   81|      0|    valuePointer.deinitialize()
   82|      0|    valuePointer.deallocate(capacity: 1)
   83|      0|    #endif
   84|      0|    
   85|      0|    return bytes
   86|      0|}
   87|       |
   88|       |extension Int {
   89|       |    /** Array of bytes with optional padding (little-endian) */
   90|      0|    func bytes(_ totalBytes: Int = MemoryLayout<Int>.size) -> [UInt8] {
   91|      0|        return arrayOfBytes(self, length: totalBytes)
   92|      0|    }
   93|       |    
   94|       |}
   95|       |
   96|       |extension NSMutableData {
   97|       |    
   98|       |    /** Convenient way to append bytes */
   99|      0|    func appendBytes(_ arrayOfBytes: [UInt8]) {
  100|      0|        append(arrayOfBytes, length: arrayOfBytes.count)
  101|      0|    }
  102|       |    
  103|       |}
  104|       |
  105|       |protocol HashProtocol {
  106|       |    var message: Array<UInt8> { get }
  107|       |    
  108|       |    /** Common part for hash calculation. Prepare header data. */
  109|       |    func prepare(_ len: Int) -> Array<UInt8>
  110|       |}
  111|       |
  112|       |extension HashProtocol {
  113|       |    
  114|      0|    func prepare(_ len: Int) -> Array<UInt8> {
  115|      0|        var tmpMessage = message
  116|      0|        
  117|      0|        // Step 1. Append Padding Bits
  118|      0|        tmpMessage.append(0x80) // append one bit (UInt8 with one bit) to message
  119|      0|        
  120|      0|        // append "0" bit until message length in bits ≡ 448 (mod 512)
  121|      0|        var msgLength = tmpMessage.count
  122|      0|        var counter = 0
  123|      0|        
  124|      0|        while msgLength % len != (len - 8) {
  125|      0|            counter += 1
  126|      0|            msgLength += 1
  127|      0|        }
  128|      0|        
  129|      0|        tmpMessage += Array<UInt8>(repeating: 0, count: counter)
  130|      0|        return tmpMessage
  131|      0|    }
  132|       |}
  133|       |
  134|      0|func toUInt32Array(_ slice: ArraySlice<UInt8>) -> Array<UInt32> {
  135|      0|    var result = Array<UInt32>()
  136|      0|    result.reserveCapacity(16)
  137|      0|    
  138|      0|    for idx in stride(from: slice.startIndex, to: slice.endIndex, by: MemoryLayout<UInt32>.size) {
  139|      0|        let d0 = UInt32(slice[idx.advanced(by: 3)]) << 24
  140|      0|        let d1 = UInt32(slice[idx.advanced(by: 2)]) << 16
  141|      0|        let d2 = UInt32(slice[idx.advanced(by: 1)]) << 8
  142|      0|        let d3 = UInt32(slice[idx])
  143|      0|        let val: UInt32 = d0 | d1 | d2 | d3
  144|      0|                         
  145|      0|        result.append(val)
  146|      0|    }
  147|      0|    return result
  148|      0|}
  149|       |
  150|       |struct BytesIterator: IteratorProtocol {
  151|       |    
  152|       |    let chunkSize: Int
  153|       |    let data: [UInt8]
  154|       |    
  155|      0|    init(chunkSize: Int, data: [UInt8]) {
  156|      0|        self.chunkSize = chunkSize
  157|      0|        self.data = data
  158|      0|    }
  159|       |    
  160|       |    var offset = 0
  161|       |    
  162|      0|    mutating func next() -> ArraySlice<UInt8>? {
  163|      0|        let end = min(chunkSize, data.count - offset)
  164|      0|        let result = data[offset..<offset + end]
  165|      0|        offset += result.count
  166|      0|        return result.count > 0 ? result : nil
  167|      0|    }
  168|       |}
  169|       |
  170|       |struct BytesSequence: Sequence {
  171|       |    let chunkSize: Int
  172|       |    let data: [UInt8]
  173|       |    
  174|      0|    func makeIterator() -> BytesIterator {
  175|      0|        return BytesIterator(chunkSize: chunkSize, data: data)
  176|      0|    }
  177|       |}
  178|       |
  179|      0|func rotateLeft(_ value: UInt32, bits: UInt32) -> UInt32 {
  180|      0|    return ((value << bits) & 0xFFFFFFFF) | (value >> (32 - bits))
  181|      0|}
  182|       |
  183|       |class MD5: HashProtocol {
  184|       |    
  185|       |    static let size = 16 // 128 / 8
  186|       |    let message: [UInt8]
  187|       |    
  188|      0|    init (_ message: [UInt8]) {
  189|      0|        self.message = message
  190|      0|    }
  191|       |    
  192|       |    /** specifies the per-round shift amounts */
  193|       |    private let shifts: [UInt32] = [7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,
  194|       |                                    5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20,
  195|       |                                    4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,
  196|       |                                    6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]
  197|       |    
  198|       |    /** binary integer part of the sines of integers (Radians) */
  199|       |    private let sines: [UInt32] = [0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,
  200|       |                               0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
  201|       |                               0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
  202|       |                               0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
  203|       |                               0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
  204|       |                               0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
  205|       |                               0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,
  206|       |                               0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
  207|       |                               0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
  208|       |                               0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
  209|       |                               0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x4881d05,
  210|       |                               0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
  211|       |                               0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,
  212|       |                               0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
  213|       |                               0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
  214|       |                               0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391]
  215|       |    
  216|       |    private let hashes: [UInt32] = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476]
  217|       |    
  218|      0|    func calculate() -> [UInt8] {
  219|      0|        var tmpMessage = prepare(64)
  220|      0|        tmpMessage.reserveCapacity(tmpMessage.count + 4)
  221|      0|        
  222|      0|        // hash values
  223|      0|        var hh = hashes
  224|      0|        
  225|      0|        // Step 2. Append Length a 64-bit representation of lengthInBits
  226|      0|        let lengthInBits = (message.count * 8)
  227|      0|        let lengthBytes = lengthInBits.bytes(64 / 8)
  228|      0|        tmpMessage += lengthBytes.reversed()
  229|      0|
  230|      0|        // Process the message in successive 512-bit chunks:
  231|      0|        let chunkSizeBytes = 512 / 8 // 64
  232|      0|
  233|      0|        for chunk in BytesSequence(chunkSize: chunkSizeBytes, data: tmpMessage) {
  234|      0|            // break chunk into sixteen 32-bit words M[j], 0 ≤ j ≤ 15
  235|      0|            var M = toUInt32Array(chunk)
  236|      0|            assert(M.count == 16, "Invalid array")
  237|      0|            
  238|      0|            // Initialize hash value for this chunk:
  239|      0|            var A: UInt32 = hh[0]
  240|      0|            var B: UInt32 = hh[1]
  241|      0|            var C: UInt32 = hh[2]
  242|      0|            var D: UInt32 = hh[3]
  243|      0|            
  244|      0|            var dTemp: UInt32 = 0
  245|      0|            
  246|      0|            // Main loop
  247|      0|            for j in 0 ..< sines.count {
  248|      0|                var g = 0
  249|      0|                var F: UInt32 = 0
  250|      0|                
  251|      0|                switch j {
  252|      0|                case 0...15:
  253|      0|                    F = (B & C) | ((~B) & D)
  254|      0|                    g = j
  255|      0|                    break
  256|      0|                case 16...31:
  257|      0|                    F = (D & B) | (~D & C)
  258|      0|                    g = (5 * j + 1) % 16
  259|      0|                    break
  260|      0|                case 32...47:
  261|      0|                    F = B ^ C ^ D
  262|      0|                    g = (3 * j + 5) % 16
  263|      0|                    break
  264|      0|                case 48...63:
  265|      0|                    F = C ^ (B | (~D))
  266|      0|                    g = (7 * j) % 16
  267|      0|                    break
  268|      0|                default:
  269|      0|                    break
  270|      0|                }
  271|      0|                dTemp = D
  272|      0|                D = C
  273|      0|                C = B
  274|      0|                B = B &+ rotateLeft((A &+ F &+ sines[j] &+ M[g]), bits: shifts[j])
  275|      0|                A = dTemp
  276|      0|            }
  277|      0|            
  278|      0|            hh[0] = hh[0] &+ A
  279|      0|            hh[1] = hh[1] &+ B
  280|      0|            hh[2] = hh[2] &+ C
  281|      0|            hh[3] = hh[3] &+ D
  282|      0|        }
  283|      0|        
  284|      0|        var result = [UInt8]()
  285|      0|        result.reserveCapacity(hh.count / 4)
  286|      0|        
  287|      0|        hh.forEach {
  288|      0|            let itemLE = $0.littleEndian
  289|      0|            let r1 = UInt8(itemLE & 0xff)
  290|      0|            let r2 = UInt8((itemLE >> 8) & 0xff)
  291|      0|            let r3 = UInt8((itemLE >> 16) & 0xff)
  292|      0|            let r4 = UInt8((itemLE >> 24) & 0xff)
  293|      0|            result += [r1, r2, r3, r4]
  294|      0|        }
  295|      0|        return result
  296|      0|    }
  297|       |}

/Users/raduj/Developer/Appub/Pods/Kingfisher/Sources/ThreadHelper.swift:
    1|       |//
    2|       |//  ThreadHelper.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 15/10/9.
    6|       |//
    7|       |//  Copyright (c) 2018 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import Foundation
   28|       |
   29|       |extension DispatchQueue {
   30|       |    // This method will dispatch the `block` to self.
   31|       |    // If `self` is the main queue, and current thread is main thread, the block
   32|       |    // will be invoked immediately instead of being dispatched.
   33|      0|    func safeAsync(_ block: @escaping ()->()) {
   34|      0|        if self === DispatchQueue.main && Thread.isMainThread {
   35|      0|            block()
   36|      0|        } else {
   37|      0|            async { block() }
   38|      0|        }
   39|      0|    }
   40|       |}

/Users/raduj/Developer/Appub/Pods/Kingfisher/Sources/UIButton+Kingfisher.swift:
    1|       |//
    2|       |//  UIButton+Kingfisher.swift
    3|       |//  Kingfisher
    4|       |//
    5|       |//  Created by Wei Wang on 15/4/13.
    6|       |//
    7|       |//  Copyright (c) 2018 Wei Wang <onevcat@gmail.com>
    8|       |//
    9|       |//  Permission is hereby granted, free of charge, to any person obtaining a copy
   10|       |//  of this software and associated documentation files (the "Software"), to deal
   11|       |//  in the Software without restriction, including without limitation the rights
   12|       |//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   13|       |//  copies of the Software, and to permit persons to whom the Software is
   14|       |//  furnished to do so, subject to the following conditions:
   15|       |//
   16|       |//  The above copyright notice and this permission notice shall be included in
   17|       |//  all copies or substantial portions of the Software.
   18|       |//
   19|       |//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   20|       |//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   21|       |//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   22|       |//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   23|       |//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   24|       |//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   25|       |//  THE SOFTWARE.
   26|       |
   27|       |import UIKit
   28|       |
   29|       |// MARK: - Set Images
   30|       |/**
   31|       | *	Set image to use in button from web for a specified state.
   32|       | */
   33|       |extension Kingfisher where Base: UIButton {
   34|       |    /**
   35|       |     Set an image to use for a specified state with a resource, a placeholder image, options, progress handler and
   36|       |     completion handler.
   37|       |     
   38|       |     - parameter resource:          Resource object contains information such as `cacheKey` and `downloadURL`.
   39|       |     - parameter state:             The state that uses the specified image.
   40|       |     - parameter placeholder:       A placeholder image when retrieving the image at URL.
   41|       |     - parameter options:           A dictionary could control some behaviors. See `KingfisherOptionsInfo` for more.
   42|       |     - parameter progressBlock:     Called when the image downloading progress gets updated.
   43|       |     - parameter completionHandler: Called when the image retrieved and set.
   44|       |     
   45|       |     - returns: A task represents the retrieving process.
   46|       |     
   47|       |     - note: Both the `progressBlock` and `completionHandler` will be invoked in main thread.
   48|       |     The `CallbackDispatchQueue` specified in `optionsInfo` will not be used in callbacks of this method.
   49|       |     
   50|       |     If `resource` is `nil`, the `placeholder` image will be set and
   51|       |     `completionHandler` will be called with both `error` and `image` being `nil`.
   52|       |     */
   53|       |    @discardableResult
   54|       |    public func setImage(with resource: Resource?,
   55|       |                         for state: UIControlState,
   56|       |                         placeholder: UIImage? = nil,
   57|       |                         options: KingfisherOptionsInfo? = nil,
   58|       |                         progressBlock: DownloadProgressBlock? = nil,
   59|       |                         completionHandler: CompletionHandler? = nil) -> RetrieveImageTask
   60|      0|    {
   61|      0|        guard let resource = resource else {
   62|      0|            base.setImage(placeholder, for: state)
   63|      0|            setWebURL(nil, for: state)
   64|      0|            completionHandler?(nil, nil, .none, nil)
   65|      0|            return .empty
   66|      0|        }
   67|      0|        
   68|      0|        let options = KingfisherManager.shared.defaultOptions + (options ?? KingfisherEmptyOptionsInfo)
   69|      0|        if !options.keepCurrentImageWhileLoading {
   70|      0|            base.setImage(placeholder, for: state)
   71|      0|        }
   72|      0|        
   73|      0|        setWebURL(resource.downloadURL, for: state)
   74|      0|        let task = KingfisherManager.shared.retrieveImage(
   75|      0|            with: resource,
   76|      0|            options: options,
   77|      0|            progressBlock: { receivedSize, totalSize in
   78|      0|                guard resource.downloadURL == self.webURL(for: state) else {
   79|      0|                    return
   80|      0|                }
   81|      0|                if let progressBlock = progressBlock {
   82|      0|                    progressBlock(receivedSize, totalSize)
   83|      0|                }
   84|      0|            },
   85|      0|            completionHandler: {[weak base] image, error, cacheType, imageURL in
   86|      0|                DispatchQueue.main.safeAsync {
   87|      0|                    guard let strongBase = base, imageURL == self.webURL(for: state) else {
   88|      0|                        completionHandler?(image, error, cacheType, imageURL)
   89|      0|                        return
   90|      0|                    }
   91|      0|                    self.setImageTask(nil)
   92|      0|                    if image != nil {
   93|      0|                        strongBase.setImage(image, for: state)
   94|      0|                    }
   95|      0|
   96|      0|                    completionHandler?(image, error, cacheType, imageURL)
   97|      0|                }
   98|      0|            })
   99|      0|        
  100|      0|        setImageTask(task)
  101|      0|        return task
  102|      0|    }
  103|       |    
  104|       |    /**
  105|       |     Cancel the image download task bounded to the image view if it is running.
  106|       |     Nothing will happen if the downloading has already finished.
  107|       |     */
  108|      0|    public func cancelImageDownloadTask() {
  109|      0|        imageTask?.cancel()
  110|      0|    }
  111|       |    
  112|       |    /**
  113|       |     Set the background image to use for a specified state with a resource,
  114|       |     a placeholder image, options progress handler and completion handler.
  115|       |     
  116|       |     - parameter resource:          Resource object contains information such as `cacheKey` and `downloadURL`.
  117|       |     - parameter state:             The state that uses the specified image.
  118|       |     - parameter placeholder:       A placeholder image when retrieving the image at URL.
  119|       |     - parameter options:           A dictionary could control some behaviors. See `KingfisherOptionsInfo` for more.
  120|       |     - parameter progressBlock:     Called when the image downloading progress gets updated.
  121|       |     - parameter completionHandler: Called when the image retrieved and set.
  122|       |     
  123|       |     - returns: A task represents the retrieving process.
  124|       |     
  125|       |     - note: Both the `progressBlock` and `completionHandler` will be invoked in main thread.
  126|       |     The `CallbackDispatchQueue` specified in `optionsInfo` will not be used in callbacks of this method.
  127|       |     
  128|       |     If `resource` is `nil`, the `placeholder` image will be set and
  129|       |     `completionHandler` will be called with both `error` and `image` being `nil`.
  130|       |     */
  131|       |    @discardableResult
  132|       |    public func setBackgroundImage(with resource: Resource?,
  133|       |                                   for state: UIControlState,
  134|       |                                   placeholder: UIImage? = nil,
  135|       |                                   options: KingfisherOptionsInfo? = nil,
  136|       |                                   progressBlock: DownloadProgressBlock? = nil,
  137|       |                                   completionHandler: CompletionHandler? = nil) -> RetrieveImageTask
  138|      0|    {
  139|      0|        guard let resource = resource else {
  140|      0|            base.setBackgroundImage(placeholder, for: state)
  141|      0|            setBackgroundWebURL(nil, for: state)
  142|      0|            completionHandler?(nil, nil, .none, nil)
  143|      0|            return .empty
  144|      0|        }
  145|      0|        
  146|      0|        let options = KingfisherManager.shared.defaultOptions + (options ?? KingfisherEmptyOptionsInfo)
  147|      0|        if !options.keepCurrentImageWhileLoading {
  148|      0|            base.setBackgroundImage(placeholder, for: state)
  149|      0|        }
  150|      0|        
  151|      0|        setBackgroundWebURL(resource.downloadURL, for: state)
  152|      0|        let task = KingfisherManager.shared.retrieveImage(
  153|      0|            with: resource,
  154|      0|            options: options,
  155|      0|            progressBlock: { receivedSize, totalSize in
  156|      0|                guard resource.downloadURL == self.backgroundWebURL(for: state) else {
  157|      0|                    return
  158|      0|                }
  159|      0|                if let progressBlock = progressBlock {
  160|      0|                    progressBlock(receivedSize, totalSize)
  161|      0|                }
  162|      0|            },
  163|      0|            completionHandler: { [weak base] image, error, cacheType, imageURL in
  164|      0|                DispatchQueue.main.safeAsync {
  165|      0|                    guard let strongBase = base, imageURL == self.backgroundWebURL(for: state) else {
  166|      0|                        completionHandler?(image, error, cacheType, imageURL)
  167|      0|                        return
  168|      0|                    }
  169|      0|                    self.setBackgroundImageTask(nil)
  170|      0|                    if image != nil {
  171|      0|                        strongBase.setBackgroundImage(image, for: state)
  172|      0|                    }
  173|      0|                    completionHandler?(image, error, cacheType, imageURL)
  174|      0|                }
  175|      0|            })
  176|      0|        
  177|      0|        setBackgroundImageTask(task)
  178|      0|        return task
  179|      0|    }
  180|       |    
  181|       |    /**
  182|       |     Cancel the background image download task bounded to the image view if it is running.
  183|       |     Nothing will happen if the downloading has already finished.
  184|       |     */
  185|      0|    public func cancelBackgroundImageDownloadTask() {
  186|      0|        backgroundImageTask?.cancel()
  187|      0|    }
  188|       |
  189|       |}
  190|       |
  191|       |// MARK: - Associated Object
  192|       |private var lastURLKey: Void?
  193|       |private var imageTaskKey: Void?
  194|       |
  195|       |extension Kingfisher where Base: UIButton {
  196|       |    /**
  197|       |     Get the image URL binded to this button for a specified state.
  198|       |     
  199|       |     - parameter state: The state that uses the specified image.
  200|       |     
  201|       |     - returns: Current URL for image.
  202|       |     */
  203|       |    public func webURL(for state: UIControlState) -> URL? {
  204|       |        return webURLs[NSNumber(value:state.rawValue)] as? URL
  205|       |    }
  206|       |    
  207|       |    fileprivate func setWebURL(_ url: URL?, for state: UIControlState) {
  208|       |        webURLs[NSNumber(value:state.rawValue)] = url
  209|       |    }
  210|       |    
  211|       |    fileprivate var webURLs: NSMutableDictionary {
  212|       |        var dictionary = objc_getAssociatedObject(base, &lastURLKey) as? NSMutableDictionary
  213|       |        if dictionary == nil {
  214|       |            dictionary = NSMutableDictionary()
  215|       |            setWebURLs(dictionary!)
  216|       |        }
  217|       |        return dictionary!
  218|       |    }
  219|       |    
  220|       |    fileprivate func setWebURLs(_ URLs: NSMutableDictionary) {
  221|       |        objc_setAssociatedObject(base, &lastURLKey, URLs, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
  222|       |    }
  223|       |    
  224|       |    fileprivate var imageTask: RetrieveImageTask? {
  225|       |        return objc_getAssociatedObject(base, &imageTaskKey) as? RetrieveImageTask
  226|       |    }
  227|       |    
  228|       |    fileprivate func setImageTask(_ task: RetrieveImageTask?) {
  229|       |        objc_setAssociatedObject(base, &imageTaskKey, task, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
  230|       |    }
  231|       |}
  232|       |
  233|       |
  234|       |private var lastBackgroundURLKey: Void?
  235|       |private var backgroundImageTaskKey: Void?
  236|       |
  237|       |
  238|       |extension Kingfisher where Base: UIButton {
  239|       |    /**
  240|       |     Get the background image URL binded to this button for a specified state.
  241|       |     
  242|       |     - parameter state: The state that uses the specified background image.
  243|       |     
  244|       |     - returns: Current URL for background image.
  245|       |     */
  246|       |    public func backgroundWebURL(for state: UIControlState) -> URL? {
  247|       |        return backgroundWebURLs[NSNumber(value:state.rawValue)] as? URL
  248|       |    }
  249|       |    
  250|       |    fileprivate func setBackgroundWebURL(_ url: URL?, for state: UIControlState) {
  251|       |        backgroundWebURLs[NSNumber(value:state.rawValue)] = url
  252|       |    }
  253|       |    
  254|       |    fileprivate var backgroundWebURLs: NSMutableDictionary {
  255|       |        var dictionary = objc_getAssociatedObject(base, &lastBackgroundURLKey) as? NSMutableDictionary
  256|       |        if dictionary == nil {
  257|       |            dictionary = NSMutableDictionary()
  258|       |            setBackgroundWebURLs(dictionary!)
  259|       |        }
  260|       |        return dictionary!
  261|       |    }
  262|       |    
  263|       |    fileprivate func setBackgroundWebURLs(_ URLs: NSMutableDictionary) {
  264|       |        objc_setAssociatedObject(base, &lastBackgroundURLKey, URLs, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
  265|       |    }
  266|       |    
  267|       |    fileprivate var backgroundImageTask: RetrieveImageTask? {
  268|       |        return objc_getAssociatedObject(base, &backgroundImageTaskKey) as? RetrieveImageTask
  269|       |    }
  270|       |    
  271|       |    fileprivate func setBackgroundImageTask(_ task: RetrieveImageTask?) {
  272|       |        objc_setAssociatedObject(base, &backgroundImageTaskKey, task, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
  273|       |    }
  274|       |}

